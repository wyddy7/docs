# Лабораторная работа №3

Исключения и прерывания в защищённом режиме процессора X86 их обработка.

## Сокращения

- **BIOS** – Base Input/Output System – базовая система ввода/вывода
- **WSL** – Windows Subsystem for Linux – подсистема Windows для Linux
- **MBR** – Master Boot Record – главная загрузочная запись
- **CHS** – Cylinder-Head-Sector – цилиндр-головка-сектор
- **GPT** – GUID (Globally Unique Identifier) Partition Table – таблица разделов глобальных уникальных идентификаторов
- **LBA** – Logical Block Addressing – логическая блочная адресация
- **AT&T** – American Telephone and Telegraph
- **GDT** – Global Descriptor Table – глобальная таблица дескрипторов
- **LDT** – Local Descriptor Table – локальная таблица дескрипторов
- **GDTR** – Global Descriptor Table Register – регистр глобальной таблицы дескрипторов
- **IDT** – Interrupt Descriptor Table – дескрипторная таблица прерываний
- **IDTR** – Interrupt Descriptor Table Register – регистр дескрипторной таблицы прерываний
- **PIC** – Programmable Interrupt Controller – программируемый контроллер прерываний

## Цель работы

Целью данной лабораторной работы является изучение механизма работы обработчика исключений и прерываний, а также написание собственных обработчиков.

В процессе выполнения работы студенты:

- Изучат основные виды исключений и прерываний, их классификацию и особенности
- Поймут причины возникновения исключений и способы их обработки
- Напишут и протестируют собственные обработчики исключений и прерываний

## Необходимые инструменты

- Любой дистрибутив GNU/Linux: рекомендуется Ubuntu, также можно использовать виртуальную машину, например, WSL
- Ассемблер: `as`
- Компоновщик: `ld`
- Утилиты для анализа объектных файлов: `objdump`, `readelf`
- Препроцессор: `cpp`
- Утилита для работы с дисками: `dd`
- Отладчик: `gdb`
- Эмулятор: `qemu`
- Утилиты для автоматизации сборки проектов: `make`

## Исходные файлы лабораторной работы

Файлы, которые используются в лабораторной работе:

- **linker.ld** - скрипт линковщика
- **Makefile** - необходимый для автоматизированной сборки проекта
- **lab3_1.s** - содержит программу с обработчиками различных исключений
- **lab3_2.s** - содержит программу с обработчиками прерываний клавиатуры и таймера
- **gdt.h, idt.h, irq.h** – макросы и константы
- **boot.S** - содержит программу загрузчика
- **Makefile** - для автоматизированной сборки загрузчика
- **linker.ld** - для сборки загрузчика

## Материалы для подготовки к лабораторной работе

### Понятие прерывания и исключения

**Прерывание (англ. Interrupt)** – это событие, вызывающее прекращение работы основной программы и переход к выполнению процедуры или подпрограммы, предназначенной для его обработки.

Практически все системы ввода/вывода в компьютере работают с использованием прерываний. В частности, когда вы нажимаете клавиши или щёлкаете мышью, аппаратура вырабатывает прерывания. В ответ на них система считывает код нажатой клавиши или запоминает координаты курсора мыши. Прерывания вырабатываются контроллером диска, портами последовательной передачи данных, звуковым адаптером и другими устройствами.

Подробнее о скан-коде можно прочитать: https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B0%D0%BD-%D0%BA%D0%BE%D0%B4

Основная цель введения прерываний - реализация асинхронного режима работы и распараллеливания работы отдельных устройств вычислительного комплекса. Механизм прерываний реализуется аппаратно-программными средствами. Прерывание непременно ведёт за собой изменение порядка выполнения команд процессором.

**Главные функции механизма прерывания:**

1. Распознавание или классификация прерывания
2. Передача управления обработчику прерывания
3. Корректное возвращение к прерванной программе

**Виды прерываний:**

- **аппаратные прерывания**, которые инициируются внешними устройствами с помощью запросов на прерывания.
- **программные прерывания**, которые инициируются специальными командами (например, int21h для х86).
- **особые случаи или исключения**, вызванные возникновением особых условий (случаев) при выполнении текущей команды.

**Типы внешних прерываний:**

- **Немаскируемые** - обрабатываются всегда, независимо от запретов на другие прерывание. К примеру, такое прерывание может вызвать сбой в микросхеме памяти
- **Маскируемые** - которые можно запрещать установкой соответствующих битов в регистре маскирования прерываний (сбросом флага IF в регистре флагов). Они генерируются контроллером прерываний по заявке определённых периферийных устройств

**Классификация исключений в защищённом режиме:**

- **Нарушение (Fault)** - такой особый случай, который обнаруживается процессором до возникновения фактической ошибки. После устранения обработчиком причины должен быть выполнен рестарт текущей команды.
- **Ловушка (Trap)** - такой особый случай, который обнаруживается процессором после выполнения виновной команды. То есть команда сама инициирует переход к обработчику и после его завершения выполнение прерванной программы продолжается со следующей команды.
- **Аварийное завершение (Abort)** - такой особый случай, при котором нельзя установить его причину и выполнить рестарт команды.

### Основные исключения процессора X86

- **Ошибка деления (0)** – автоматически формируется, когда в команде DIV или IDIV делитель равен нулю или частное слишком велико для получателя (AL, AX, EAX).
- **Отладка (1)** – формируется в следующих случаях:
  - Нарушение к.т. по адресу команды;
  - Нарушение к.т. по адресу данных;
  - Ловушка покомандной работы (TF = 1);
  - Ловушка контрольной точки по переключению задачи (бит Т=1 в сегменте TSS).
- **Немаскируемое прерывание NMI (2)** – единственное внешнее радиальное прерывание.
- **Контрольная точка (3)** – формируется при выполнении однобайтной команды INT3 (код 0cch).
- **Переполнение (4)** – возникает при выполнении команды INT0 при условии, что OF=1.
- **Нарушение границы массива (5)** – возникает при выполнении команды BOUND, если контрольная проверка дает отрицательный результат.
- **Недействительный код операции (6)** – генерируется, когда операционное устройство процессора обнаруживает неверный код операции.
- **Устройство недоступно (7)** – возникает в двух случаях:
  - Процессор выполняет команду ESC и бит ЕМ=1 в CR0.
  - Процессор выполняет команду wait или ESC и бит TS=1 в CR1.
- **Двойное нарушение (8)** – когда процессор обнаруживает особый случай при попытке вызвать обработчик предыдущего особого случая.
- **Недействительный сегмент TSS (10)** – возникает при попытке переключения на задачу с неверным TSS.
- **Неприсутствие сегмента (11)** – формируется, когда бит Р=0 в дескрипторе сегмента.
- **Нарушение стека (12)** – возникает в двух ситуациях:
  - Нарушение предела сегмента при обращении к регистру SS (POP, PUSH, ENTER, MOV AX, [BP+6]);
  - При попытке загрузить в регистр SS дескриптор, который отмечен как неприсутствующий.
- **Нарушение общей защиты (13)** – все нарушения защиты, которые не служат причиной конкретного особого случая.
- **Страничное нарушение (14)** – возникает, когда разрешено страничное преобразование и имеет место одна из ситуаций:
  - В элементе PDE или PTE сброшен бит Р;
  - Процедура не имеет достаточного уровня привилегий для доступа к адресуемой странице.
- **Ошибка операции с плавающей точкой (16)** – сигнализирует об ошибке, возникшей при выполнении команды FPU.
- **Контроль выравнивания (17)** – возникает при нарушении выравнивания операндов.

Подробнее можно почитать:
- https://osdev.fandom.com/ru/wiki/IAM:%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_5
- https://habr.com/ru/companies/timeweb/articles/780082/
- https://clck.ru/3GDKjo

### Таблица прерываний и исключений защищённого режима

Таблица прерываний защищённого режима называется дескрипторной таблицей прерываний IDT (Interrupt Descriptor Table).

Также как и таблицы GDT и LDT, таблица IDT содержит 8-байтовые дескрипторы.

Её расположение определяется содержимым 6-байтового внутреннего регистра процессора IDTR. Формат регистра IDTR полностью аналогичен формату регистра GDTR, для его загрузки используется команда LIDT.

Таблица дескрипторов прерываний (IDT) связывает каждый вектор исключения или прерывания с дескриптором шлюза для процедуры или задачи, которая используется для обработки соответствующего исключения или прерывания. Как и GDT (глобальная таблица дескрипторов) и LDT (локальные таблицы дескрипторов), IDT представляет собой массив 8-байтовых дескрипторов (в защищённом режиме). В отличие от GDT, первая запись в IDT может содержать дескриптор. Для формирования индекса в IDT процессор умножает вектор исключения или прерывания на восемь (количество байтов в дескрипторе шлюза). Поскольку существует только 256 векторов прерываний или исключений, в IDT должно находиться не более 256 дескрипторов. Все пустые слоты дескрипторов в IDT должны иметь флаг присутствия (present flag) установленным в 0.

Перед тем, как передать управление обработчику исключения, для многих зарезервированных прерываний аппаратные средства процессора помещают в стек 16-битовый код ошибки. Этот код ошибки программа может проанализировать и тем самым получить некоторую дополнительную информацию об ошибке.

### Программируемый контроллер прерываний

Программируемый контроллер прерываний (Programmable Interrupt Controller, PIC) отвечает за приём запросов прерываний от различных устройств, их хранение в ожидании обработки, выделение наиболее приоритетного из одновременно присутствующих запросов и выдачу его вектора в процессор, когда последний пожелает обработать прерывание.

**Источники запросов прерываний:**

- IRQ0 - программируемый интервальный таймер или высокоточный таймер событий №0
- IRQ1 - клавиатура PS/2
- IRQ2 - запрос прерывания от ведомого контроллера прерываний
- IRQ3 - произвольное устройство (в IBM PC/AT - последовательный порт COM2 и COM4)
- IRQ4 - произвольное устройство (в IBM PC/AT - последовательный порт COM1 и COM3)
- IRQ5 - произвольное устройство (в IBM PC/AT - параллельный порт LPT2)
- IRQ6 - произвольное устройство (в IBM PC/AT - контроллер гибких дисков)
- IRQ7 - произвольное устройство (в IBM PC/AT - параллельный порт LPT1)
- IRQ8 - часы реального времени или высокоточный таймер событий №1
- IRQ9 - произвольное устройство
- IRQ10 - произвольное устройство
- IRQ11 - произвольное устройство или высокоточный таймер событий №2
- IRQ12 - произвольное устройство, обычно мышь PS/2, либо высокоточный таймер событий №3
- IRQ13 - ошибка арифметического сопроцессора
- IRQ14 - произвольное устройство, обычно первый контроллер ATA (или контроллер Serial ATA в режиме совместимости)
- IRQ15 - произвольное устройство, обычно второй контроллер ATA (или контроллер Serial ATA в режиме совместимости)

Контроллер прерываний (8259A) имеет следующие регистры:

- **IMR** - регистр масок, установленные биты указывают, какие номера прерываний запретить обрабатывать
- **IRR** - регистр запросов на прерывание, содержит номера поступивших запросов на прерывание, бит соответствующему запросу сбрасывается после подтверждения прерывания (IMR на IRR не влияет)
- **ISR** - регистр обслуживаемых прерываний, указывает номера обслуживаемых прерываний

Прерывания от отдельных устройств можно запретить, устанавливая в регистре масок IMR контроллера, соответствующие им биты. Запретить прерывания от всех устройств можно очисткой бита IF в регистре флагов центрального процессора.

Подробнее можно почитать: https://ibzh.eko3.ru/asm/irq.htm

### Как работать с GDB?

- `b *адрес` - установить точку останова по адресу
- `x/40i` - дизассемблировать 40 инструкций, начиная с адреса
- `display/i $eip` - отображать следующую инструкцию при каждом шаге
- `c` - продолжить выполнения программы до следующей точки останова
- `stepi` - выполнить одну инструкцию (ассемблерный шаг)

## Вопросы для самоконтроля

1. Что такое прерывание и как оно работает в процессоре?
2. Какие виды прерываний существуют (аппаратные, программные, исключения)?
3. В чём разница между немаскируемыми и маскируемыми прерываниями?
4. Какие типы исключений существуют (сбой, ловушка, аварийное завершение)?
5. Что такое IDT (Interrupt Descriptor Table) и как она используется в защищённом режиме?
6. Как процессор определяет, какой обработчик вызвать при возникновении прерывания или исключения?
7. Какие данные хранятся в дескрипторе шлюза прерывания?
8. Как загружается и настраивается IDT?
9. Как процессор обрабатывает исключения, такие как деление на ноль или недопустимый код операции?
10. Что происходит с регистрами и стеком при возникновении исключения?
11. Как написать собственный обработчик исключения на ассемблере?
12. Как установить точку останова в GDB?
13. Как просмотреть состояние регистров и стека в GDB?
14. Как дизассемблировать код в GDB и сравнить его с исходным ассемблерным кодом?

## Выполнение лабораторной работы

### Часть 1. Подготовка к выполнению лабораторной работы

1. Создайте директорию для выполнения лабораторной работы `mkdir lab3` и перейти в неё `cd lab3`, создайте директорию `img`, в ней будут храниться файлы необходимые для загрузчика.
2. Создайте по примеру лабораторной работы №1 необходимые для данной лабораторной работы файлы упомянутые в разделе исходные файлы. Скопируйте код предоставленный в приложении.

### Часть 2. Выполнение лабораторной работы 3_1

#### 2.1. Запуск программы

Запустите программу, наблюдайте успешное выполнение.

#### 2.2. Тест деления на ноль

Отредактируйте файл `lab3_1.S`: расскомментируйте строки кода, где производится деление на 0

#### 2.3. Сборка

Соберите программу, используя команду `make 1`

#### 2.4. Запуск с исключением

Запустите программу с помощью команды `qemu-system-i386 -hda boot.img -m 32`. Посмотрите на вывод текста об исключении

#### 2.5. Анализ адресов

С помощью команды `objdump -m i386 -D lab3_1.elf` вы можете найти адрес обработчика исключений, а также адрес начала стека

#### 2.6. Отладка

Запустите отладчик GDB. Не забудьте добавить флаги `-s -S` в команду `qemu-system-i386 -hda boot.img -m 32`

#### 2.7. Анализ стека

Покажите стек до и после появления исключения, опишите, что в нём присутствует.

**Подсказка:**
- Перейдите на адрес инструкции, которая вызывает исключение
- Вы можете распечатать стек с помощью команды `x/16x $esp+адрес_начала_стека`
- Сделайте шаг в программе с помощью `stepi` (попадёте в обработчик исключения)

**Задание для lab3_1:**

Проведите действия пункта 2.1. - 2.5. для несуществующей инструкции(ud2), int nop nop nop, несуществующего селектора.

Выберите исключение в IDT равное остатку от деления вашего номера в группе на 17 (исключения с null_descr в IDT пропускать), добавьте в код программы действия которые его вызовут и проанализируйте его также, как и предыдущие.

### Часть 3. Выполнение лабораторной работы 3_2

#### 3.1. Сброс флага прерываний

Сбросьте флаг прерываний в обработчике прерывания int 80 (trap_handler).

#### 3.2. Сборка

Соберите программу, используя команду `make 2`

#### 3.3. Запуск и тестирование

Запустите программу с помощью команды `qemu-system-i386 -hda boot.img -m 32`.

Попробуйте ввести текст с клавиатуры, а также обратите внимание на таймер (пока выводится текст на зелёном фоне, если нужно, увеличьте задержку вывода текста).

#### 3.4. Тест с флагом прерываний

Сбросьте флаг прерываний в обработчике прерываний клавиатуры (keyboard_ISR), установите флаг прерываний, пересоберите программу, запустите её.

#### 3.5. Проверка работы

Попробуйте вводить текст с клавиатуры, обратите внимание на вывод текста на зелёном фоне, таймер.

#### 3.6. Запрет прерываний клавиатуры

Запретите прерывания клавиатуры в инициализации регистра маски первого КП, пересоберите программу, запустите её.

#### 3.7. Проверка запрета

Проверьте, что действительно обработки прерываний при нажатии клавиш не происходит.

#### 3.8. Тест без EOI

Верните флаги прерываний, разрешите прерывания клавиатуры, отключите отправку EOI в обработчике прерывания клавиатуры, пересоберите и запустите программу, наблюдайте эффект.

#### 3.9. Отладка

Включив отправку EOI, пересоберите программу, запустите её с поддержкой GDB/

#### 3.10. Исследование обработчиков

Подключившись по GDB исследуйте работу обработчиков прерываний (клавиатуры, таймера, int 80h).

**Дополнительно задание для lab3_2:**

Измените код так, чтобы при отжатии клавиатуры не выводился циркумфлекс (символ `^`)

## Защита

1. Объясните, как процессор обрабатывает прерывания и исключения в защищённом режиме.
2. Какие данные помещаются в стек при возникновении исключения? Как эти данные используются для восстановления состояния программы?
3. В чём разница между сбоем (Fault), ловушкой (Trap) и аварийным завершением (Abort)?
4. Перепишите обработчик прерывания для клавиатуры, так, чтобы он выводил скан-код нажатой клавиши на экран.
5. После возникновения исключения, проверьте содержимое стека. Какие данные были помещены в стек, и как они связаны с состоянием программы до исключения?

## Приложение

Полный код программ, Makefile, linker.ld и другие файлы находятся в исходных документах лабораторной работы.

