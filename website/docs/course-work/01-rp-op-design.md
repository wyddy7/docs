# Методические указания по проектированию регистровой и оперативной памяти на ПЛИС

## Контекст

Данная методичка посвящена изучению различных способов проектирования регистровой (РП) и оперативной (ОП) памяти для учебного процессора на ПЛИС фирмы ALTERA. Студенты познакомятся с библиотечным модулем `altsyncram`, научатся использовать помощник MegaWizard Plug-In Manager, а также создавать модули памяти на языке VHDL с использованием шаблонов. Методичка содержит детальное описание нескольких версий проектов с пошаговыми инструкциями и результатами моделирования.

## Для кого этот документ

-   Студентам 3-4 курса, выполняющим курсовую работу по организации ЭВМ
-   Требования: знание Quartus II, MegaWizard Plug-in Manager, VHDL
-   Необходимое ПО: Quartus II версии 13.1 или новее

## Цель работы

Изучение методики проектирования регистровой и оперативной памяти в проектах на ПЛИС фирмы ALTERA с использованием мегафункций из библиотеки параметризованных модулей (LPM).

## Где найти файлы проекта

Все файлы проектов, рассматриваемых в методическом пособии, находятся в папке OP. И сам проект, и его базовая версия носит название `module_OP`.

**Ссылка на репозиторий:** [https://github.com/mf-bmstu-k3/OP](https://github.com/mf-bmstu-k3/OP)

## Что нужно знать перед началом

-   Принципы организации памяти (адресация, чтение/запись)
-   Различия между регистровой (Register File) и оперативной (RAM) памятью
-   Использование MegaWizard Plug-in Manager для генерации ядер

## Содержание

1. Исследование библиотечного модуля altsyncram в базовой версии проекта module_OP
2. Создание модуля регистровой памяти для учебного процессора путем дополнительного редактирования библиотечного модуля памяти altsyncram
3. Создание модуля РП с использованием помощника MegaWizard Plug-In Manager
4. Создание модуля ОП с помощью MegaWizard Plug-In Manager
5. Создание модуля РП с использованием шаблона на языке VHDL
6. Создание модуля регистровой памяти для конвейерного процессора

## 1. Исследование библиотечного модуля altsyncram в базовой версии проекта module_OP

Целью базовой версии этого проекта является изучение библиотечного параметризованного модуля синхронной памяти, для последующего его использования в учебных проектах.

Все файлы проектов, рассматриваемых в методическом пособии, находятся в папке OP. И сам проект, и его базовая версия носит название `module_OP`. Модулем верхнего уровня в ней является схемный проект, содержащийся в файле `Module_altsyncram.bdf`. Он создан в QUARTUS II версии 13.1 из библиотечного модуля `altsyncram`, путем редактирования его портов и параметров. В методическом пособии проводится исследование этого модуля для определения возможности его использования в курсовой работе для реализации на его основе оперативной (ОП) и регистровой памяти (РП) учебного процессора.

### 1.1 Как создан проект

Следует напомнить, что для создания схемного файла выполняем следующие шаги. В меню `File` выбираем строку `New…`, затем задаем тип создаваемого файла `Block Diagram/Schematic File`, указав его в выпадающем списке и нажимаем `OK`.

Далее из библиотеки QII из раздела `megafunctions` выбираем тип мегафункции `storage`, модуль `altsyncram` и добавляем его символ в схемный проект. Выполняем редактирование библиотечного модуля. Для этого выделяем символ на схеме, и в контекстном меню, вызываемом нажатием правой кнопки мыши, выбираем `Properties`.

Затем во вкладке `General` присваиваем экземпляру редактируемого модуля памяти имя «RР», подчеркивая этим его последующее использование в качестве регистровой памяти учебного процессора.

В вкладке `Ports` редактируем внешние порты экземпляра модуля памяти. В столбце `Status` оставляем нужные, указав `Used`, и удаляем ненужные, указав `Unused`. Для изменения состояния порта достаточно кликнуть левой кнопкой мыши в соответствующей клетке столбца. В рассматриваемом проекте из предлагаемых в универсальном библиотечном модуле 23 портов оставляем 12 входных и два выходных. Символьное обозначение экземпляра модуля памяти после его редактирования приведено на рис. 1. Как видно на рисунке, создан экземпляр модуля памяти, с двумя независимыми портами а и b, который обеспечит одновременную выборку содержимого двух регистров, что будет востребовано в учебном процессоре.

![Рис.1 Символьное обозначение модуля памяти altsyncram](image/rp-op-design/1763728855069.png)

Далее во вкладке `Parameter` выполняем редактирование параметров создаваемого экземпляра модуля регистровой памяти. В соответствии с ТЗ регистровая память учебного процессора содержит восемь восьмиразрядных регистров. Поэтому в экземпляре модуля РП для каждого порта используем трехразрядную адресную шину, и две восьмиразрядные шины данных, причем отдельные, для записи и считывания данных. Сигналы `rden_a` и `rden_b` разрешают чтение из соответствующих портов памяти. Сигналы `wren_a` и `wren_b` разрешают запись в РП через порты а и b, соответственно. Сигналы `clock0` и `clock1` используются в качестве тактовых для обоих портов, а сигналы `clocken0` и `clocken1` разрешают модулю РП реагировать на тактовые сигналы.

Настройку других параметров РП можно посмотреть в таблице 1, скопированной с символьного обозначения этого модуля в проекте. При необходимости можно выполнить их дополнительное редактирование. Для этого необходимо выделить модуль памяти на схемном проекте, вызвать контекстное меню с помощью правой клавиши мыши и выбрать в нем команду `Properties`.

В таблице 1 приводится список настроенных параметров модуля РП с выполненными назначениями.

В процессе настройки и редактирования параметров модуля памяти можно задать файл, который будет использован для инициализации памяти. В предлагаемом проекте таким файлом является файл `mem_file.hex`, который также содержится в папке с проектом. На рисунке 2 показано его содержимое.

![Рис.2 Содержимое файла mem_file.hex, инициализации модуля РП](image/rp-op-design/1763728863631.png)

Следует напомнить, что для создания нового файла в проекте используем команду `New…` из меню `File`, или соответствующую пиктограмму на панеле инструментов QII. Далее задаем тип создаваемого файла, указав его в выпадающем списке, заполняем файл и сохраняем его с назначенным именем.

Как следует из рисунка 2, после использования указанного файла для инициализации памяти в ней будут храниться легкозапоминаемые выразительные значения. Так, по нулевому адресу в ней будет нулевое значение, по адресу 1- 0х11, 2- 0х22 и так далее.

### 1.2 Моделирование созданного экземпляра модуля РП

Чтобы исследовать поведение созданного экземпляра модуля РП подготовлен файл с временными диаграммами `test_RP.vwf`, также входящий в состав проекта. Фрагмент временной диаграммы с результатами функционального моделирования созданного экземпляра модуля РП с использованием указанного файла приведен на рисунке 3.

![Рис.3. Чтение из РП с использованием обоих портов](image/rp-op-design/1763728870995.png)

Для отображения информации на адресных шинах РП на временных диаграммах используется десятичная форма представления чисел без знака, на шинах данных РП, - шестнадцатеричная форма представления чисел без знака. Для остальных сигналов используется бинарное представление.

Выполним анализ показанных на рисунке 3 результатов. На шине адреса первого порта в каждом такте формируются последовательные значения. На шине адреса порта b в каждом такте значения формируются случайным образом. Во временном интервале с 0 до 60 нс активны сигналы, разрешающие чтение и тактирование для обоих портов, сигналы записи, наоборот, не активны.

Видим на выходной шине `q_a` вначале нулевое значение, и только в третьем такте, в момент времени 25 нс, по положительному фронту синхросигнала `clock0` появляется содержимое первого регистра РП, в следующем такте – второго, и так далее до того момента, пока сигнал разрешения тактирования первого порта РП перестанет быть активным. На временной диаграмме это событие происходит в 60нс.

Далее на выходной шине первого порта `q_a` сохраняется считанное из РП в предыдущем такте значение, то есть 0х44, несмотря на то что информация на адресном входе и входе данных меняется в каждом такте. Обратите внимание на то, что информация на выходе первого порта РП появляется с задержкой в два такта, относительно задаваемого на его входе адреса. Объясняется это тем, что по положительному фронту синхросигнала заданный на внешней шине адрес 1 запоминается во внутреннем регистре адреса РП, в следующем такте из РП извлекается его содержимое 0х11 и фиксируется в выходном регистре РП. Поэтому содержимое первого регистра мы наблюдаем на выходе РП только в следующем такте.

Иначе на временной диаграмме выглядит поведение выходной шины `q_b` второго порта РП. На нем информация появляется в том же такте по положительному фронту синхросигнала, после выставления нового адреса на шине адреса `address_b`. В первом такте мы наблюдаем на выходе `q_b` значение 0х44, что соответствует содержимому четвертого регистра, в следующем такте 0х33 - содержимое третьего регистра, затем 0х66 – содержимое шестого регистра и т.д.

На рисунке 4 показан фрагмент временной диаграммы, отражающий запись в РП через первый её порт.

![Рис. 4. Запись в РП по адресу 0 значения 0х74 через порт a](image/rp-op-design/1763728881375.png)

На рисунке видим, что при активном сигнале `wren_a` в момент времени 160 нс на шине адреса первого порта установлено значение 0, на входной шине данных - 0х74. Следовательно должна выполняться запись в нулевой регистр значения 0х74. Аналогичным образом выполняется запись в момент времени 270 нс в третий регистр РП значения 0х00, что показано на рисунке 5.

![Рис. 5. Запись в РП по адресу 3 нулевого значения через порт а](image/rp-op-design/1763729177385.png)

Чтение обновленного значения с нулевого адреса РП через порт а можем видеть на временной диаграмме в момент времени 335 нс. Этот фрагмент приведен на рисунке 6. Чтение с нулевого адреса через порт b можем наблюдать на рисунке 7 в момент времени 435 нс.

![Рис. 6. Чтение содержимого нулевого адреса РП через порт a](image/rp-op-design/1763729193820.png)

![Рис. 7. Чтение содержимого нулевого адреса РП через порт b](image/rp-op-design/1763729327391.png)

Чтение регистра 3 РП через первый порт мы можем видеть в момент времени 365 нс на рисунке 8. Чтение регистра 3 через второй порт b мы можем наблюдать в момент времени 535 нс на рисунке 9.

![Рис. 8. Чтение из регистра 3 РП нулевого значения через порт а](image/rp-op-design/1763729337278.png)

![Рис. 9. Чтение из регистра 3 РП нулевого значения через порт b](image/rp-op-design/1763729346385.png)

На рисунках 10 и 11 приведены фрагменты временной диаграммы, на которых отсутствует сигнал разрешения чтения из РП через первый и второй порты соответственно. На рисунке 10 мы видим, что сигнал `rden_a` не активен в интервале 490 – 540 нс. В этом же интервале после первого положительного фронта синхросигнала на выходной шине `q_a` РП мы видим значение 0х74, которое ранее было записано в нулевой регистр РП в момент времени 165 нс.

![Рис.10. Поведение РП, когда нет сигнала разрешения чтения rden_a](image/rp-op-design/1763729353120.png)

Обратите внимание на то, что в интервале 490 -500 нс при запрещенном сигнале чтения из первого порта РП активен сигнал `wren_a`, разрешающий запись в РП. Так как в этом интервале на адресном входе `address_a` РП установлена единица, а на входной шине данных нулевое значение, то выполнится запись в первый регистр нулевого значения. Корректность выполнения записи в РП мы можем проверить на временной диаграмме на этом же рисунке в момент времени 585 нс, когда выполняется чтение первого регистра РП.

![Рис. 11. Поведение РП, когда нет сигнала разрешения чтения rden_b](image/rp-op-design/1763729360802.png)

На рисунке 11 показана ситуация, когда запрещено чтение из РП через второй порт в интервале 730 - 780 нс. На выходной её шине `q_b` в это время видим значение 0х44, которое хранилось в четвертом регистре РП, и было считано из него в момент времени 725 нс, когда чтение из РП было еще разрешено.

Сигнал `clocken0`, разрешающий тактирование первого порта РП, не активен в интервалах 60 – 150 нс. Фрагмент временной диаграммы с результатами моделирования РП на этом интервале показан на рис. 12. Как видно на рисунке, изменение на шине выходных данных `q_a` первого порта в этом интервале не происходит. Наблюдаемое в этом интервале значение 0х44 представляет собой содержимое четвертого регистра, считанное из него в момент времени 55 нс, когда сигнал разрешения тактирования первого порта ещё был активен.

![Рис. 12 Чтение из РП, когда нет разрешения тактирования первого порта](image/rp-op-design/1763729370826.png)

Другой интервал, во время которого запрещено тактирование второго порта показан на рис. 13. На нем видим, что сигнал `clocken1` не активен в интервале 310-410 нс. В этом интервале на выходной шине `q_b` наблюдаем нулевое значение, которое ранее было записано в регистр 3 РП в момент времени 275 нс через первый порт.

![Рис 13. Чтение из РП, когда нет разрешения тактирования второго порта](image/rp-op-design/1763729379766.png)

Тактовый сигнал для первого порта РП `clock0` отсутствует в интервалах 110 -120 нс и 230 –250 нс. В первом интервале его отсутствие никак не влияет на поведение РП. Объясняется это тем, что в этом же интервале также отсутствует сигнал разрешения тактирования первого порта `clocken0`. Смотрите рисунок 12. Фрагмент временной диаграммы, отражающий поведение РП во втором интервале, показан на рисунке 14.

![Рис.14 Поведение РП, когда отсутствует тактовый сигнал для первого порта](image/rp-op-design/1763729403054.png)

На рисунке 14 в этом интервале на выходной шине `q_a` первого порта видим значение 0х55, которое изначально хранилось в пятом регистре РП и было считано из него в момент времени 235 нс по положительному фронту предыдущего тактового импульса.

На рисунке 15 показана ситуация, когда в интервале 450 - 460 нс отсутствует сигнал тактирования второго порта. Из него следует, что в это время значение 0х74 на выходной шине `q_b` не меняется. Оно соответствует содержимому нулевого регистра, которое ранее было в него записано в момент времени 165 нс. Смотрите рисунок 4.

![Рис.15. Поведение РП, когда отсутствует тактовый сигнал для второго порта](image/rp-op-design/1763729414638.png)

## 2. Создание модуля регистровой памяти для учебного процессора путем дополнительного редактирования библиотечного модуля памяти altsyncram

### 2.1 Рекомендации по использованию библиотечного модуля для реализации на его основе памяти регистровой

Выполнив исследование библиотечного модуля памяти `altsyncram`, делаем следующее заключение о возможности его применения для реализации регистровой памяти учебного процессора:

-   Для тактирования обоих портов РП достаточно использовать один синхронизирующий сигнал. В следующей версии проекта РП он назван `clock0`.
-   Сигналы `clocken0` и `clocken1`, разрешающие тактирование обоих портов памяти, являются избыточными, поэтому в следующей версии проекта РП использовать их не будем.
-   Сигналы `rden_a`, `rden_b`, разрешающие чтение из первого и второго портов, также не нужны для реализации РП. Пусть чтение из РП будет разрешено всегда.
-   Буферный регистр, для фиксации считываемых с первого порта данных в РП также не нужен. Помимо аппаратных затрат он еще и вносит дополнительную задержку в один такт. По этой причине в следующей версии проекта РП использовать его не будем.

### 2.2 Вторая версия проекта РП

На основе базовой версии проекта `module_OP`, рассмотренной в первом разделе пособия, создана новая версия проекта с именем `RP_from_altsyncram`. Новая версия получена путем дополнительного редактирования библиотечного модуля памяти в соответствии с рекомендациями, изложенными выше. Модулем верхнего уровня в ней является схемный проект с именем `Modul_altsyncram_after_edit`, подчеркивающим его происхождение.

На рис 16 показано символьное обозначение модуля РП после дополнительного редактирования его портов и параметров. Обновленный экземпляр модуля памяти назван `RP_1`.

![Рис.16 Обновленное символьное обозначение модуля РП](image/rp-op-design/1763729426814.png)

В таблице 2, скопированной с символьного обозначения модуля РП из проекта, приводится список его обновленных параметров.

Обратите внимание, фиксация считываемых из первого порта данных теперь не выполняется. Для тактирования обоих портов теперь используется единый тактовый сигнал `clock0`.

Внесены изменения и в файл с временными диаграммами для тестирования РП. Они свелись к удалению невостребованных входных сигналов. Измененный файл теперь называется `test_for_RP1`. Он также содержится в проекте.

Выполнив моделирование, убеждаемся в полной работоспособности созданного экземпляра модуля памяти с именем `RP_1`.

## 3. Создание модуля РП с использованием помощника MegaWizard Plug-In Manager

Целью этой версии проекта является знакомство студентов с менеджером мегафункций, встроенным в пакет QII.

### 3.1 Третья версия модуля РП

Создаем новую версию проекта с именем `RP_from_megawizard`. Как и в предыдущих проектах, модулем верхнего уровня в ней является одноименный схемный проект. Создаем его так. При обращение в библиотеку QII в появившемся окне нажимаем кнопку `MegaWizard Plug-In Manager`. Соответствующее окно показано на рисунке 17.

![Рис.17 Кнопка вызова встроенного помощника MegaWizard](image/rp-op-design/1763729444156.png)

Следует заметить, что альтернативным способом вызова менеджера мегафункций является выполнение команды `MegaWizard Plug-In Manager` из меню `Tools` пакета QII.

Далее в методическом пособии показаны появляющиеся в процессе диалога с менеджером окна и их заполнение. В первом окне предлагается задать действие, которое мы хотим выполнить. Из предложенного списка выбираем создание новой конфигурации мегафункции. Смотрите рис. 18.

![Рис. 18 Первое окно помощника MegaWizard](image/rp-op-design/1763729453963.png)

В следующем окне 2а, показанном на рисунке 19, выбираем `RAM: 2-PORT`, то есть модуль двухпортовой памяти, язык описания, и задаем имя формируемого менеджером файла с описанием конфигурации мегафункции. В нашем случае, это файл `RP2` на языке VHDL.

![Рис. 19. Окно выбора мегафункции, языка описания и задания имени создаваемого файла с описанием конфигурации мегафункции](image/rp-op-design/1763729464625.png)

Следующее окно 3 менеджера приведено на рисунке 20. На нем отражены три этапа конфигурирования мегафункции, показано символьное обозначение формируемого модуля РП и затрачиваемые на его реализацию ресурсы кристалла ПЛИС, а также приводится ряд вопросов, на которые необходимо ответить. В частности, предлагается указать режим использования двух портов модуля памяти и указать способ определения размера памяти. В нашем случае указываем, что оба порта используются для чтения и записи, то есть являются полноценными, и что размер памяти будем задавать как количество слов.

![Рис.20 Окно задания режима работы портов памяти и способа указания размера памяти](image/rp-op-design/1763729472620.png)

В следующем, четвертом окне менеджера, приведенном на рисунке 21, предлагается указать число слов в памяти и указать разрядность портов, если она разная. Также в этом окне можно указать, на каких ресурсах кристалла будет реализован создаваемый модуль РП. В нашем случае используем модуль двухпортовой памяти размером восемь восьмиразрядных слов, с одинаковой разрядностью обоих портов, как указано в ТЗ на проектирование учебного процессора.

![Рис. 21 Окно задания размера памяти и разрядности портов, в случае использования портов разной разрядности](image/rp-op-design/1763729483459.png)

В пятом окне менеджера, показанном на рисунке 22, требуется задать режим тактирования модуля памяти. В нашем случае используем единый сигнал синхронизации для обоих портов РП.

![Рис.22 Окно задания режима тактирования модуля памяти](image/rp-op-design/1763729491347.png)

В седьмом окне, приведенном на рисунке 23, опционально предлагается добавить регистры для фиксации считываемых из памяти данных, использовать сигнал разрешения тактирования модуля памяти и очистки содержимого добавленных регистров. Это окно заполняем так, как показано на рисунке 23.

![Рис.23 Окно 7 менеджера мегафункций и его заполнение для рассматриваемого примера](image/rp-op-design/1763729513034.png)

Замечаем, что в процессе редактирования портов РП, в окне менеджера корректируется и его символьное обозначение. В частности, после отказа от использования выходных буферных регистров в регистровой памяти их изображение исчезло с символьного обозначения РП.

В следующем, восьмом окне менеджера, показанном на рисунке 24, предлагается определить наблюдаемые на выходе одного из портов памяти данные во время записи в память через другой порт. Так как в учебном процессоре такой режим использования РП не предполагается, оставляем это окно без изменения. То есть выходные данные другого порта в этом случае будут не определены.

![Рис. 24 Восьмое окно менеджера MegaWizard](image/rp-op-design/1763729522776.png)

В девятом окне менеджера, показанном на рисунке 24, задаем поведение выходных шин `q_a` и `q_b` во время записи в память. Окно оставляем без изменения, указывая тем самым, что в этом случае на выходных шинах РП должны появляться новые данные.

![Рис.24 Девятое окно менеджера MegaWizard](image/rp-op-design/1763729537306.png)

В десятом окне задаем имя файла, используемого для инициализации РП и указываем его местоположение.

![Рис.25 Десятое окно менеджера MegaWizard, задания первоначального содержимого РП](image/rp-op-design/1763729548068.png)

Следующее 11 окно менеджера, приведенное на рисунке 26, относится ко второму этапу конфигурирования мегафункции. В этом окне ничего не меняем. Как видно на рисунке, в нём задается библиотека для моделирования мегафункции.

![Рис.26 Одиннадцатое окно менеджера MegaWizard](image/rp-op-design/1763729554333.png)

И, наконец, в последнем окне менеджера, показанном на рисунке 26, относящемся к третьему этапу конфигурирования мегафункции, выбираем, какие файлы должны быть сформированы мегавизардом. Так как в настоящем пособии демонстрируется схемный проект модуля РП, то по умолчанию, автоматически генерируется два файла проекта, файл с символьным обозначением РП с расширением bsf, и файл с описанием конфигурации мегафункции. Показаны на рисунке серым цветом. Для выбора других файлов из предложенного списка надо кликнуть мышкой в соответствующем чекбоксе.

![Рис. 26 Последнее окно менеджера MegaWizard выбора выходных файлов](image/rp-op-design/1763729560912.png)

В нашем случае указываем файлы `RP2.cmp`, с декларацией созданного компонента регистровой памяти, и `RP2_inst.vhd` с шаблоном для установки компонента в проект верхнего уровня. Эти файлы нам понадобятся в дальнейшем в проекте учебного процессора.

После завершения диалога в мегавизарде в новом окне появляется сформированное им символьное изображение модуля РП, показанное на рисунке 27. После нажатия кнопки ОК символ РП добавится в схему проекта.

![Рис.27 Сформированное менеджером Megawizard символьное обозначение модуля регистровой памяти RP2](image/rp-op-design/1763729572917.png)

Далее выделяем символ в схеме, вызываем контекстное меню с помощью правой кнопки мыши. Выполняем в нем команду `Generate Pins for Symbol Ports` для завершения проекта.

**Сформированные файлы:**

-   `RP2.vhd` - описание созданного компонента модуля РП на языке VHDL
-   `RP2.cmp` - декларация созданного компонента регистровой памяти
-   `RP2.bsf` - символьный файл модуля РП
-   `RP2_inst` - шаблон для установки созданного компонента в проект верхнего уровня

Для тестирования вновь созданного модуля памяти в проекте имеется файл `test_for_RP2`. Он отличается от файла `test_for_RP1` только названием тактового сигнала. Теперь он называется просто `clock`. Выполнив моделирование созданного мегавизардом модуля регистровой памяти RP2, убеждаемся в его полной работоспособности и, следовательно, возможности использования его в проекте учебного процессора.

### 3.2 Анализ файлов, сформированных менеджером MegaWizard

Менеджером MegaWizard создаются файлы, необходимые для использования модуля РП в проекте учебного процессора. Файлы с расширением `.cmp` содержат декларацию компонентов, а файлы с суффиксом `_inst` - шаблоны для установки компонентов в проект верхнего уровня.

**Сформированные файлы:**

-   `RP2.vhd` - описание созданного компонента модуля РП на языке VHDL. Его можно найти в папке с проектом.
-   `RP2.cmp` - декларация созданного компонента регистровой памяти с именем RP2. Содержимое этого файла приведено в листинге 1.
-   `RP2.bsf` - символьный файл модуля РП
-   `RP2_inst` - шаблон для установки созданного компонента в проект верхнего уровня. Содержимое этого файла приведено в листинге 2. В нашем случае проектом верхнего уровня будет учебный процессор.

**Листинг 1.** Содержимое созданного мегавизардом файла с декларацией компонента RP2.

![Листинг 1. Содержимое созданного мегавизардом файла с декларацией компонента RP2](image/rp-op-design/1763729850111.png)

**Листинг 2.** Подготовленный мегавизардом шаблон для установки компонента RP2 в проект учебного процессора.

![Листинг 2. Подготовленный мегавизардом шаблон для установки компонента RP2 в проект учебного процессора](image/rp-op-design/1763729859094.png)

## 4. Создание модуля ОП с помощью MegaWizard Plug-In Manager

### 4.1 Рекомендации по использованию библиотечного модуля для реализации на его основе оперативной памяти для учебного процессора

На основании анализа поведения библиотечного модуля `altsyncram`, делаем следующее заключение относительно реализации на его основе оперативной памяти для учебного процессора:

1. В соответствии с ТЗ оперативная память ОП в процессорной системе должна содержать 256 восьмиразрядных слов
2. Для доступа ко всему адресному пространству ОП будем использовать восьмиразрядную шину адреса `address_OP`
3. Второй порт для реализации ОП не требуется, поэтому в библиотечном модуле памяти будем использовать один единственный порт
4. Буферный регистр для фиксации считываемых из ОП данных также не требуется
5. Для разрешения записи в ОП будем использовать сигнал `wr_en_OP`
6. Во время записи на выходной шине будут присутствовать вновь записываемые данные
7. Потребуется файл инициализации памяти для размещения программного кода и исходных данных

### 4.2 Версия проекта модуля ОП

Модуль оперативной памяти для учебного процессора создан с использованием MegaWizard Plug-In Manager аналогичным образом, с учетом рекомендаций, изложенных выше. Версия проекта, в которой реализован модуль ОП, называется `OP_from_megawizard`. Как и в предыдущих проектах, для большей наглядности, модулем верхнего уровня в ней является одноименный схемный файл, показанный на рисунке 28.

![Рис. 28 Символьное обозначение созданного менеджером модуля оперативной памяти](image/rp-op-design/1763729926887.png)

**Характеристики модуля ОП:**

-   Размер: 256 восьмиразрядных слов
-   Адресная шина: 8 разрядов
-   Один порт для чтения и записи
-   Без выходных буферных регистров
-   Файл инициализации: `OP_init.mif`

Для тестирования модуля ОП подготовлен файл инициализации памяти с именем `OP_init.mif`. Фрагмент этого файла представлен на рисунке 29. Используется беззнаковая десятичная форма как для отображения адресов, так и содержимого ячеек ОП. Как следует из рисунка, первые восемь байт после инициализации модуля ОП будут содержать некоторые значения (вторая строка на рисунке), а начиная с восьмого адреса все последующие байты, для удобства отладки, будут содержать каждый свой адрес.

![Рис.29 Фрагмент файла OP_init.mif, инициализации оперативной памяти](image/rp-op-design/1763729936627.png)

Последовательность входных сигналов для тестирования модуля ОП находится в файле `test_for_OP`, который входит в состав проекта. Сигналы на на шинах адреса и данных, как и в файле OP_init.mif, представлены с использованием десятичной беззнаковой формы представления чисел. Тестовая последовательность сформирована следующим образом.

В интервале 0-770 нс выполняется последовательное формирование адресов на адресной шине, начиная с нулевого и до 76-го, включительно. На шине входных данных значения формируются случайным образом на всем интервале наблюдения. Сигнал `wren`, разрешающий запись в ОП, активен в интервалах, когда на адресной шине ОП установлены выразительные адреса с одинаковыми цифрами 11, 22, 33, 44, 55, 66. Следовательно, по этим адресам будет выполняться запись новых значений, которые присутствуют в это время на входной шине данных `data`. Они также появляются и на выходной шине `q` в этих же интервалах по положительному фронту тактового сигнала `clock`.

Фрагмент с результатами моделирования поведения ОП показан на рисунке 30. На нем видно, что считываемые из последовательных адресов ОП значения, соответствуют содержимому файла инициализации памяти OP_init.mif. Исключением являются ячейки с адресами 11 и 22, в которые выполняется запись новых значений 235 и 90, соответственно.

![Рис. 30 Фрагмент с результатами моделирования поведения ОП](image/rp-op-design/1763729946626.png)

Проверка корректности записи в ОП, включая перечисленные выше ячейки, выполняется в интервале 770 - 830 нс, когда происходит чтение их содержимого. Соответствующий фрагмент временной диаграммы с результатами моделирования ОП приведен на рисунке 31. На нем видно, что чтение обновленного содержимого ОП выполняется корректно.

![Рис. 31 Чтение обновленных ячеек ОП в интервале 770-830 нс](image/rp-op-design/1763729954562.png)

В оставшемся интервале 830-1000 нс значения на адресной шине формируются рандомно. И снова на временной диаграмме наблюдаем корректное поведение модуля ОП.

Таким образом, моделирование ОП показало его полную работоспособность и, следовательно, возможность использования его в качестве оперативной памяти в проектируемой процессорной системе.

### 4.3 Анализ файлов, сформированных менеджером MegaWizard

Менеджером MegaWizard создаются следующие файлы:

-   `Module_OP.vhd` - описание созданного компонента модуля ОП на языке VHDL. Его можно найти в папке с проектом.
-   `Module_OP.cmp` - декларация созданного компонента оперативной памяти с именем Module_OP. Его содержимое приведено в листинге 3.
-   `Module_OP.bsf` - символьный файл модуля ОП
-   `Module_OP_inst` - шаблон для установки созданного компонента в проект верхнего уровня. В нашем случае таким проектом будет учебный процессор. Сам шаблон показан в листинге 4.

**Листинг 3.** Содержимое файла Module_OP.cmp

![Листинг 3 Содержимое файла Module_OP.cmp](image/rp-op-design/1763730033672.png)

**Листинг 4.** Шаблон для вставки компонента ОП в проект.

![Листинг 4. Шаблон для вставки компонента ОП в проект](image/rp-op-design/1763730043527.png)

На рисунке 32 показан отчет о компиляции модуля ОП. Из него следует, что этот модуль, размером 2048 бит, действительно реализован с использованием ресурсов блочной памяти в кристалле ПЛИС.

![Рис. 32 Отчет о компиляции модуля OP_from_megawizard](image/rp-op-design/1763730059506.png)

На рисунке 33 показано внутреннее представление созданного компонента ОП, полученное c помощью инструмента RTL Viewer. Следует напомнить, что для его вызова в пакете QII используется команда `Tools Menu => Netlist Viewers`. Как видно на рисунке, из 23 внешних выводов универсального библиотечного модуля памяти altsyncram в реализованном компоненте ОП используется только пять. В левой части рисунка отображается иерархическое представление проекта.

![Рис. 33 Реализация модуля ОП на базе библиотечного элемента altsyncram](image/rp-op-design/1763730069842.png)

## 5. Создание модуля РП с использованием шаблона на языке VHDL

### 5.1 Четвертая версия модуля РП

В этом разделе рассматривается проектирование модуля РП для учебного процессора на языке VHDL, с использованием шаблона из пакета QII.

**Создание проекта:**

1. В меню `Project` выбираем команду `Revisions…`
2. В появившемся окне выбираем строку `New revision` и присваиваем ей имя `RP_from_template`
3. Создаем новый VHDL файл, сохраняем его с именем `RP_from_template`
4. В файле вызываем окно вставки шаблона, нажав на соответствующую пиктограмму на панеле инструментов QII. В появившемся окне выбираем `VHDL > Full Designs > RAMs and ROMs > True Dual-Port RAM (single clock)`, как показано на рисунке 34. Нажимаем кнопку вставки `Insert`, после чего выполняем его редактирование.

![Рис. 34 Выбор шаблона с описанием двухпортового модуля памяти](image/rp-op-design/1763730080899.png)

5. Выполняем редактирование шаблона:
    - В строке 21 шаблона меняем разрядность адреса на три, что соответствует требованию ТЗ, на проектирование учебного процессора
    - В строках 16, 37, 39 заменяем предложенное в шаблоне имя модуля памяти на собственное имя `RP_from_template`
    - В строках 46, 47 файла задаем первоначальное содержимое РП. Для совместимости с предыдущими версиями проекта задаем его так, чтобы оно соответствовало файлу `mem_file.hex`, содержимое которого показано на рисунке 2. Следует заметить, что правильнее было бы разместить первоначальное содержимое РП в отдельном пакете, который следует добавить к проекту. Тогда, в случае необходимости изменения его содержимого достаточно будет изменить только пакет, не меняя сам файл проекта с описанием РП.

### 5.2 Моделирование созданного экземпляра модуля РП

В файле `test_for_RP3` содержатся временные диаграммы для моделирования РП. Фрагмент временной диаграммы с результатами моделирования модуля РП показан на рисунке 35.

![Рис.35 Фрагмент временной диаграммы с результатами моделирования РП](image/rp-op-design/1763730093996.png)

На рисунке видим, что на адресной шине первого порта формируются последовательные значения адресов. На выходной шине `q_а` в интервале 0 -80 нс видим значения, которыми была инициализирована регистровая память. На выходной шине `q_b` в этом же интервале видим содержимое РП, считываемое из него в другой последовательности. Она соответствует последовательности значений адресов, формируемых на адресной шине второго порта `addr_b` случайным образом.

В следующем интервале 80 -160 нс выполняется запись в РП через первый порт а, причем такими значениями, которые присутствуют в это время на шине данных `data_a`. Следует заметить, что значения на шинах `data_a`, `data_b`, как и на шине `addr_b` формируются случайным образом. На выходной шине `q_a` в этом интервале мы видим значения, совпадающие с записываемыми.

На рисунке 36 показаны результаты моделирования РП в следующем интервале 160-320 нс. В интервале 160-240 нс выполняется последовательное чтение содержимого памяти через первый её порта а. На рисунке видно, что данные читаются из РП в той последовательности, в которой они записывались в РП в предыдущем интервале.

![Рис. 36 Результаты моделирования модуля РП](image/rp-op-design/1763730102274.png)

В интервале 240- 320 нс происходит обновление РП через второй его порт b. Правильность выполнения записи подтверждается результатами моделирования РП в последующем временном интервале.

Таким образом, мы убеждаемся в корректном поведении, созданного в этой версии с помощью шаблона модуля РП.

Отчет о компиляции проекта воспроизведен на рисунке 37.

![Рис. 37 Отчет о компиляции проекта РП с использованием шаблона из QII](image/rp-op-design/1763730112394.png)

**Особенности реализации:**

Из него следует, что в отличие от предыдущих проектов, модуль РП теперь реализован полностью из элементов памяти, входящих в состав логических ячеек ПЛИС. Причем потребовалось 80 таких элементов. Объясняется это так. Сами регистры 8 штук по 8 разрядов требуют 64 элементов памяти. Оставшиеся 16 элементов используются для фиксации считываемых из РП данных 2\*8, в каждом порту по положительному фронту.

Внутреннее представление модуля РП в кристалле ПЛИС, полученное с помощью RTL Viewer, показано на рисунке 38.

![Рис. 38 Представление с помощью RTL Viewer реализованного в ПЛИС модуля РП](image/rp-op-design/1763730122079.png)

### 5.3 Сравнительный анализ разных версий проекта РП

Обратите внимание на то, что в QII при создании проекта верхнего уровня можно в качестве шаблона использовать сформированные ранее менеджером MegaWizard файлы с декларацией компонентов и файлы с шаблонами для их установки в проект. Следует напомнить, что первые имеют расширение `.cmp`, а вторые дополнительное слово `_inst` в имени файла.

Рисунок 39 подтверждает вышесказанное утверждение. На нем мы видим предлагаемые пакетом QII шаблоны для созданных ранее менеджером MegaWizard компонентов РП и ОП с именами RP2 и Module_OP, соответственно.

![Рис.38 Шаблон с декларацией компонента оперативной памяти Module_OP](image/rp-op-design/1763730140097.png)

![Рис. 39 Шаблон с декларацией компонента регистровой памяти RP2](image/rp-op-design/1763730149529.png)

![Рис. 40 Шаблон для установки экземпляра модуля ОР в проект верхнего уровня](image/rp-op-design/1763730155111.png)

![Рис. 41 Шаблон для установки экземпляра модуля RP2 в проект верхнего уровня](image/rp-op-design/1763730160928.png)

Сравнительный анализ рассмотренных в учебно-методическом пособии четырех версий проекта регистровой памяти приведен на рисунке 42. Показанное в нем окно скопировано с проекта. Для его получения используется команда `Project=> Revisions…` В появляющемся окне нажимаем кнопку `Compare…`, как показано на рисунке 43.

![Рис. 42 Сравнительный анализ четырех версий проекта регистровой памяти](image/rp-op-design/1763730170137.png)

![Рис. 43 Кнопка сравнения разных версий одного проекта](image/rp-op-design/1763730182226.png)

**Версии проекта РП:**

1. Базовая версия - `module_OP` (исследование библиотечного модуля)
2. Вторая версия - `RP_from_altsyncram` (дополнительное редактирование)
3. Третья версия - `RP_from_megawizard` (создание с помощью MegaWizard)
4. Четвертая версия - `RP_from_template` (создание на языке VHDL)

## 6. Создание модуля регистровой памяти для конвейерного процессора

Основным форматом для команд RISC процессора является формат R, в котором задаются адреса трех регистров из РП:

-   Два регистра RA и RB используются для выборки операндов
-   Третий регистр RС используется для записи результата выполненной операции

Другим востребованным форматом является формат I, в котором непосредственный операнд задается прямо в самой команде. Разрядность его, как правило, составляет половину от длины команды. Если операнд является числом со знаком, то при выполнении операции в АЛУ он расширяется до полного слова знаковым разрядом. Если операнд - число без знака, то в этом случае он расширяется до полного слова нулями. Вторым операндом в командах I формата является содержимое регистра процессора, результат же выполненной операции также записывается в один из регистров РП.

**Требования к регистровой памяти RISC процессора:**

Для регистровой памяти RISC процессора потребуется трехпортовая память:

-   Два порта в каждом такте читают содержимое двух регистров из РП
-   Один порт может выполнять запись в РП

## Чеклист выполнения

-   [ ] Изучен библиотечный модуль `altsyncram` в базовой версии проекта `module_OP`
-   [ ] Проведено моделирование базового модуля РП, проанализировано поведение при различных сигналах управления
-   [ ] Создана вторая версия проекта РП `RP_from_altsyncram` с упрощенной конфигурацией
-   [ ] Создана третья версия проекта РП `RP_from_megawizard` с использованием MegaWizard Plug-In Manager
-   [ ] Проанализированы файлы, сформированные менеджером MegaWizard (RP2.vhd, RP2.cmp, RP2_inst)
-   [ ] Создан модуль ОП `OP_from_megawizard` с использованием MegaWizard Plug-In Manager
-   [ ] Проведено моделирование модуля ОП, проверена запись и чтение данных
-   [ ] Создан файл инициализации `OP_init.mif` для оперативной памяти
-   [ ] Создана четвертая версия проекта РП `RP_from_template` на языке VHDL
-   [ ] Проведено моделирование модуля РП, созданного с использованием шаблона
-   [ ] Выполнен сравнительный анализ всех четырех версий проекта РП
-   [ ] Модули интегрированы в общий проект учебного процессора

## Часто задаваемые вопросы (FAQ)

**Q: В чем разница между `lpm_ram_dq` и `altsyncram`?**
A: `lpm_ram_dq` - это старая мегафункция, которая может реализовываться на логических ячейках (LE) или блоках памяти. `altsyncram` - более новая и гибкая функция, ориентированная на использование встроенных блоков памяти (Block RAM) в ПЛИС Altera/Intel, и поддерживает больше режимов (True Dual Port и т.д.).

**Q: Почему при моделировании на выходе памяти `X` (неопределенность)?**
A: Это происходит, если вы пытаетесь читать из адреса, в который ничего не записывали. Память при старте не инициализирована (если не подключен `.mif` или `.hex` файл). Для исправления запишите что-нибудь по адресу перед чтением или используйте файл инициализации.

**Q: Как создать `.mif` файл?**
A: В Quartus II выберите `File -> New -> Memory Initialization File`. Укажите размерность (Depth и Width) и заполните ячейки значениями. Затем укажите этот файл в настройках мегафункции памяти.

**Q: В чем разница между регистровой (РП) и оперативной (ОП) памятью?**
A: Регистровая память (Register File) - это быстрая память небольшого объема, используемая для хранения регистров процессора. Обычно имеет несколько портов для одновременного чтения нескольких регистров. Оперативная память (RAM) - это память большего объема для хранения программ и данных. В учебном процессоре РП содержит 8 восьмиразрядных регистров, а ОП - 256 восьмиразрядных слов.

**Q: Зачем нужны сигналы `clocken0` и `clocken1`?**
A: Эти сигналы разрешают тактирование соответствующих портов памяти. Однако для простых проектов они могут быть избыточными, если тактирование всегда активно. В упрощенных версиях проекта их можно не использовать.

**Q: Что такое выходной буферный регистр и зачем он нужен?**
A: Выходной буферный регистр фиксирует данные на выходе памяти по положительному фронту тактового сигнала. Это добавляет задержку в один такт, но обеспечивает синхронность выходных данных. Для регистровой памяти, где важна скорость, его часто не используют.

**Q: Какой способ создания модуля памяти лучше использовать?**
A: Каждый способ имеет свои преимущества:

-   Редактирование библиотечного модуля - для изучения и понимания всех параметров
-   MegaWizard Plug-In Manager - для быстрого создания с удобным интерфейсом
-   VHDL шаблоны - для полного контроля над реализацией и обучения языку описания аппаратуры

## Дополнительные материалы

-   [Документация по мегафункциям Altera (User Guide)](https://www.intel.com/content/www/us/en/docs/programmable/683424/current/introduction-to-megafunctions.html)
-   [Quartus II Handbook - Memory Blocks](https://www.intel.com/content/www/us/en/programmable/documentation/)
-   [VHDL Templates in Quartus II](https://www.intel.com/content/www/us/en/programmable/documentation/)
-   [Примеры .mif файлов](https://github.com/efremovnv/docs/tree/main/examples/mif)
-   [Altera/Intel FPGA Memory Resources](https://www.intel.com/content/www/us/en/programmable/documentation/)
