# Лабораторная работа №7

Использование интерфейса JTAG для взаимодействия процессорной системы с инструментальным компьютером

## Цель работы

Изучение порта JTAG UART и практическое его использование для взаимодействия процессорной системы, реализованной на стенде, с оператором за инструментальным компьютером.

## Планируемые результаты обучения

После выполнения этой работы студенты должны уметь:

- Вводить информацию в процессорную систему, используя клавиатуру инструментального компьютера;
- Выводить информацию из процессорной системы в терминальное окно инструментального компьютера.
- Выполнять ввод и вывод информации с использованием прерывания текущей программы
- Использовать вложенные прерывания от таймера

## Исходные файлы лабораторной работы

Программа, демонстрирующая использование JTAG UART порта в процессорной системе, является составной частью приложения AMP. Она доступна в разделе Sample program под именем JTAG UART.s.

## Подготовка к лабораторной работе

Для выполнения лабораторной работы необходимо изучить по материалам лекций и предложенной литературе:

1. Организацию обмена данными между стендом и инструментальным компьютером.
2. Принцип работы и назначение регистров и отдельных полей JTAG UART порта. Эта информация содержится в описании процессорной системы «DE2-70 Media Computer» [9]. Включите ее в отчет.
3. Реализацию прерываний в процессорной системе с процессором NIOSII[8]. Используемые для этого регистры процессора и портов ввода – вывода.
4. Особенности использования вложенных прерываний.
5. Уясните принцип действия программы, работающей с интерфейсом JTAG из файла JTAG UART.s. Включите ее в отчет.
6. Уясните содержимое фрагмента программы TEST_DE2_70_Media_Computer из листинга 9 приложения и включите его в отчет.
7. Уясните пункты задания, выполняемого в текущей лабораторной работе, и подготовьте программные заготовки для их выполнения.

В лабораторной работе ASCII-коды символов, введенных в терминальном окне AMP, отправляются в процессорную систему, реализованную на стенде с использованием UART JTAG интерфейса, отображаются на светодиодах и 7-сегментных индикаторах, затем отправляются обратно в инструментальный компьютер, и отображаются в терминальном окне AMP.

## Материалы для подготовки

### Что такое JTAG

Когда речь идет о JTAG, прежде всего, подразумевается стандарт: IEEE 1149.1-2001 Test Access Port and Boundary-Scan Architecture (Стандарт IEEE 1149.1-2001 Порт тестового доступа и Архитектура Граничного сканирования).

С ростом степени интеграции БИС, плотности монтажа и появлением многослойных печатных плат, методы диагностики, основанные на подключении к контрольным точкам платы и выводам микросхем, становятся все более сложными в использовании и неэффективными.

В начале 1985 года объединенными усилиями нескольких европейских компаний была создана группа для разработки решения проблем тестирования интегральных схем, цифровых устройств и систем. Эта группа получила имя: Joint European Test Action Group (JETAG). Позднее, в 1988 году к ней присоединились представители североамериканских компаний, и название было изменено на Joint Test Action Group (JTAG).

Результатом работы этой группы явился принятый в 1990 году стандарт IEEE Std.1149.1 и его усовершенствованная версия: стандарт IEEE Std.1149.1a (1993 год).

В основу стандарта положена идея внедрение в компоненты цифрового устройства средств, обеспечивающих унифицированный подход к решению следующих задач:

- Тестирование связей между интегральными схемами, после того, как они были смонтированы на печатной плате или другой основе;
- Наблюдение за работой компонент без вмешательства в их нормальную работу, или непосредственное управление одним или более компонентом;
- Обеспечение стандартизованного доступа к произвольным средствам самотестирования, встраиваемым в БИС;

### Порт тестового доступа: TAP (Test Access Port)

Когда мы говорим о передаче информации через JTAG, то мы подразумеваем обмен между ведущим устройством и встроенными в БИС средствами тестирования. Для этой цели был разработан TAP (Test Access Port)—Порт Тестового Доступа.

Аппаратная поддержка поддержки JTAG реализуется достаточно простыми схемами. TAP требует 4-х внешних контактов:

- **TDI (Test Data Input)** — контакт для получения последовательных данных. На этот контакт последовательно, бит-за-битом подаются данные, которые затем интерпретируются схемой управления;
- **TDO (Test Data Output)** — контакт вывода последовательных данных. С этого контакта ведущее устройство последовательно считывает данные из БИС (например результат тестовых операций);
- **TCK (Test Clock Input)** — контакт сигнала синхронизации обмена;
- **TMS (Test Mode Select)** — этот контакт управляет состоянием внутреннего автомата TAP. В частности, с помощью этого контакта определяется что грузиться: команда или данные, а также определяется начало и конец загрузки;

Следующий контакт не является обязательным для реализации:

- **TRST (Test ReSeT)** — сброс в начальное состояние контроллера внутреннего автомата TAP

### JTAG порт в процессорной системе

JTAG порт реализует соединение между стендом DE2-70 и инструментальным компьютером. Это соединение используется пакетом Quartus II для загрузки файла программирования в кристалл ПЛИС на плате, посредством чего создаётся процессорная система. Соединение также используется приложением AMP для загрузки программы в процессорную систему и управления её выполнением.

Порт JTAG включает универсальный асинхронный приемопередатчик (UART), который может использоваться для передачи символьных данных между инструментальным компьютером и программой, выполняемой в процессорной системе на стенде. Причем обмен между процессором Nios II и портом JTAG осуществляется параллельным кодом, а между JTAG и инструментальным компьютером последовательным кодом.

Если на инструментальном компьютере используется приложение AMP, то для передачи символьных данных в порт JTAG их следует печатать в терминальном окне приложения, предварительно поместив туда курсор с помощью мыши. Вывод символов в порт JTAG из процессорной системы Nios II будет приводить к отображению их в терминальном окне приложения АМР, выполняющегося на инструментальном компьютере.

Программный интерфейс JTAG порта состоит из двух 32-битных регистров:

- Регистр, доступный по адресу **0x10001000**, является регистром данных.
- Регистр, доступный по адресу **0x10001004**, является регистром управления.

Когда символьные данные из инструментального компьютера посылаются в JTAG UART, то они сохраняются в 64-символьном буфере FIFO. Число символов, хранимых в настоящий момент в буфере FIFO, указывается в поле **RAVAIL**, которое представлено разрядами 31-16 регистра данных. Если буфер FIFO переполнен, то дополнительно посылаемые в него данные со стороны инструментального компьютера будут потеряны. Если данные присутствуют в буфере FIFO, то величина RAVAIL будет больше нуля и 15-ый бит регистра данных **RVALID** будет равен 1.

Чтобы осуществить чтение символа из вершины буфера FIFO, необходимо прочитать содержимое регистра данных JTAG порта. При этом младшие разряды 7-0 регистра данных будут содержать вводимый символ. Поле RAVAIL при выполнении чтения автоматически уменьшится на единицу.

Контроллер JTAG UART также включает 64-символьный буфер FIFO, который хранит данные, ожидающие передачи в инструментальный компьютер. Символьные данные загружаются в этот буфер посредством записи в разряды 7-0 регистра данных. Размер доступного пространства в текущий момент времени в записываемом буфере FIFO указывается в разрядах 31-16 регистра управления. Это поле **WSPACE**. Если буфер FIFO полон, то все данные, в последующем записываемые в регистр данных, будут теряться.

Бит 10 в регистре управления, названный **AC**, устанавливается в 1, если к JTAG UART был доступ со стороны инструментального компьютера. Этот бит может быть использован для проверки наличия установленного соединения инструментального компьютера с платой DE2-70. Бит АС может быть вновь очищен посредством записи в него 1.

### Прерывания от JTAG UART

Биты **RE** и **WE** регистра управления используются для того, чтобы разрешить прерывания процессора, связанные с приемом или передачей символов. Если прерывание разрешено, то оно будет происходить, когда RAVAIL для буфера FIFO принимаемых данных превысит 7, или WSPACE для буфера FIFO отправляемых данных станет меньше 7. Произошедшие прерывания будут сопровождаться установкой в 1 разрядов **RI** и **WI** в регистре управления, которые потом могут быть очищены путем чтения или записи данных из/в JTAG UART.

## Порядок выполнения лабораторной работы

### Часть 1. Запись в UART JTAG (вывод информации)

1. Напишите программу, которая записывает символ z в порт UART JTAG. Предусмотрите в программе анализ поля WSPACE в регистре управления UART, отражающего наличие свободного места в буфере FIFO для записываемых символов. Реализуйте выход из программы, если свободного места в буфере нет.

2. Отладьте программу. По содержимому поля WSPACE определите размер буфера FIFO. Используйте для этого вкладку Memory приложения AMP. Измените символ z на другой символ.

3. Модифицируйте программу из предыдущего пункта таким образом, чтобы символы выводились многократно. Реализуйте программную задержку в цикле вывода. Подберите задержку таким образом, чтобы происходили следующие события:
   - Программа завершается по переполнению буфера FIFO, и при этом выводится в терминальное окно AMP минимальное количество символов. Подсчитайте количество выведенных символов. Сравните со значением, полученным в пункте 2.
   - Буфер FIFO никогда не переполняется, и программа реализует бесконечный цикл.
   - Буфер FIFO успевает вывести некоторое количество символов до того, как он переполнится.
   
   Запишите в отчет подобранные задержки.

4. Напишите программу, которая выводит в терминальное окно AMP некоторое сообщение. Сообщение разместите в сегменте данных программы. Для этого используйте директиву `.asciz` ассемблера. Программа должна анализировать выводимый байт, и если он равен нулю, то вывод должен прекращаться. Оформите эту программу в виде процедуры, которая в последующем может быть использована для вывода из процессорной системы различных сообщений. Параметром, передаваемым этой процедуре, является адрес текстовой строки в сегменте данных. В качестве тестового примера выведите свою фамилию, имя и отчество. Сделайте снимок на смартфон и поместите его в отчетные материалы.

### Часть 2. Чтение из JTAG UART (ввод информации)

1. Напишите подпрограмму, которая выполняет чтение из порта UART JTAG. Подпрограмма должна анализировать бит RVALID в регистре данных UART. Если этот бит равен 1, считанные данные присутствовали в буфере FIFO и они достоверны. В противном случае, данных в буфере нет, и подпрограмма должна ожидать их появления. Принятый из UART JTAG символ, основная программа должна отобразить на светодиодах и двух 7-сегментных индикаторах, записать обратно в JTAG и так далее в цикле. Отладьте подпрограмму.

2. С помощью AMP скомпилируйте программу из предыдущего пункта и загрузите в память. Поставьте контрольную точку в программе после приема первого символа из UART JTAG. Проанализируйте поле RAVAIL. Запишите в отчет. Обратите внимание! Для анализа поля RAVAIL потребуется включить опцию Query all devices и нажать кнопку Refresh. Учтите, что при этом произойдет чтение регистра данных UART JTAG и, следовательно, удаление символа из вершины буфера FIFO и уменьшение поля RAVAIL на 1. Повторите эксперимент, но предварительно напечатайте в терминальном окне AMP несколько символов с клавиатуры. Рекомендуется набирать осмысленное сообщение, чтобы в последующем можно было бы проверить правильность его вывода в терминальное окно. Проанализируйте поле RAVAIL. Отключите опцию Query all devices, уберите контрольную точку и продолжите выполнение программы. Сравните количество выведенных символов в терминальном окне AMP с содержимым поля RAVAIL. Повторите эксперимент. Экспериментально определите размер буфера FIFO для читаемых данных.

3. Модифицируйте программу таким образом, чтобы коды печатаемых на клавиатуре символов дополнительно отображались на светодиодах и двух HEX индикаторах. Составьте таблицу кодов ASCII для десяти цифр, нескольких букв вашей фамилии. Получите коды символов Enter, Backspace. Получите коды ASCII для одной и той же клавиши прописными и заглавными буквами, в английской и русской раскладке.

4. Модифицируйте подпрограмму чтения из порта UART JTAG таким образом, чтобы ASCII-коды выводимых символов записывались в память побайтно. Ввод должен завершаться при получении символа Enter. В этом случае в конец строки должен быть добавлен нулевой байт, означающий конец строки. Подпрограмма в последующем будет полезна для реализации ввода информации в процессорную систему с клавиатуры инструментального компьютера. Отправьте сохраненную строку в UART JTAG порт, используя подпрограмму, написанную в пункте 7 первой части.

### Часть 3. Ввод из UART JTAG в режиме прерывания

1. Модифицируйте программу таким образом, чтобы ввод текстовой строки из инструментального компьютера осуществлялся в режиме прерывания. Для этого основная программа разрешает прерывания по чтению от UART JTAG и выполняет вывод строки с Вашей фамилией, именем и отчеством на дисплей LCD в режиме бегущей строки. Ввод текста в терминальном окне приводит к прерыванию основной программы, и обработчик прерывания далее осуществляет ввод строки в ОП и вывод в UART JTAG всей строки, пока не обнаружит символ конца строки. В это время вывод бегущей строки на LCD дисплей должен остановиться.

2. Модифицируйте программу таким образом, чтобы после ввода каждого символа обработчик прерывания возвращал управление основной программе. Визуально наблюдайте правильность работы программы.

### Часть 4. Ввод из JTAG UART в режиме прерывания с использованием вложенного прерывания от таймера

1. Модифицируйте программу из предыдущей части таким образом, чтобы реализовать вывод символов в терминальном окне AMP следующим образом. Набранный на клавиатуре символ выводится в терминальном окне AMP каждые 500мс.

2. Модифицируйте программу из предыдущей части таким образом, чтобы основная программа разрешила прерывания по чтению от UART JTAG и выводила бегущую строку на LCD. При нажатии клавиши клавиатуры инструментального компьютера формируется прерывание основной программы. Обработчик прерывания UART JTAG разрешает прерывания от таймера каждые 500 мс и возвращает управление основной программе. Обработчик прерывания от таймера выводит символ в терминальное окно AMP каждые 500 мс, причем, если клавиша не нажата, повторяется вывод последнего набранного символа.

### Часть 5. Вывод из процессорной системы в JTAG UART с использованием вложенного прерывания

Экспериментально определите при каком условии формируется прерывание процессорной системы при выполнении вывода символьной информации в терминальное окно инструментального компьютера. Для этого в основной программе разрешите прерывания по записи от JTAG UART. Обработчик прерывания должен вывести на экран LCD предупреждающее сообщение, проверить, освободился ли буфер FIFO, и если да, вернуть управление основной программе. Таким образом, обработчик прерывания будет срабатывать как предохранительный клапан, принудительно приостанавливая процесс дальнейшего заполнения символьной информацией буфера FIFO, позволяя тем самым в это время его освободить.

## Отчетные материалы

Отчетные материалы должны содержать:

1. Цель лабораторной работы.
2. Материалы, связанные с подготовкой к работе, включая теоретическую часть.
3. Фрагменты программ JTAG UART.s и TEST_DE2_70_Media_Computer.
4. Информацию по выполнению каждого пункта задания. Причем в отчете должны содержаться выполняемые Вами действия, наблюдаемые результаты, и Ваши объяснения.
5. Написанные Вами фрагменты программ.
6. Краткое заключение.

## Приложение

### Листинг 8. Текст программы JTAG UART.s

```asm
/****************************************************************
 * Программа выполняет следующее: 
 *       1. отправляет символьную строку  из текстовой строки в JTAG UART
 *       2. считывает данные из JTAG UART
 *       3. отправляет считанные данные обратно в JTAG UART
********************************************************************/

.text									
.global	_start
_start:

movia 	sp, 0x07FFFFFC			/* Определяем адрес вершины стека */

movia		r6, 0x10001000			

movia		r8, TEXT_STRING			/* адрес текстовой строки в r8 */
:
ldb		r5, 0(r8)			/* из текстовой строки в r5*/
call		PUT_JTAG                /* вызываем процедуру, которая помещает символ в JTAG */

addi		r8, r8, 1
	
br					/* переходим на вывод очередного символа */

GET_JTAG:
ldwio		r4, 0(r6)		/*читаем регистр управления JTAG UART*/
andi		r8, r4, 0x8000	           /*проверяем есть ли новые данные*/
beq		r8, r0, GET_JTAG	/*если данных нет, то ожидаем их появления*/
andi		r5, r4, 0x00ff	           /*получаем данные*/

call		PUT_JTAG		/*отправляем символ обратно в JTAG UART*/
call		GET_JTAG

.end		
									
/********************************************************************
* Подпрограмма, которая выводит символы в JTAG UART
*		r5	= выводимый символ
*		r6	= JTAG UART базовый адрес
********************************************************************/

.global	PUT_JTAG			
PUT_JTAG:			
		
	/* сохраняем используемые регистры */	

subi		sp, sp, 4				/* резервирум место в стеке*/
stw		r4, 0(sp)				/* сохраняем r4 в стеке */

ldwio		r4, 4(r6)		/* читаем регистр управления JTAG UART */
andhi		r4, r4, 0xffff	             /* проверяем есть ли место для записи в буфере UART */
beq		r4, r0, KONEC	/* если места нет, то переполнение буфера */
stwio		r5, 0(r6)				/* отправляем символ в UART */
			
OVERFLOW:		
			
	/* восстанавливаем содержимое r4 */

ldw		r4, 0(sp)	
addi		sp, sp, 4	

ret				

/******************************************************************/

.data			

TEXT_STRING:
.asciz	"\nJTAG UART example code\n"

.end
```

### Листинг 9. Фрагмент программы TEST_DE2_70_Media_Computer

```asm
/****************************************************************
 * Процедура анализирует, имеются ли данные в буфере чтения JTAG порта.
 * Если есть, то данные отправляются обратно в JTAG порт и дополнительно в 
 * COM-порт. Если новых данных нет, то выполняется проверка, имеются ли данные в буфере чтения com-порта. Если данные есть, то они отправляются обратно в com-порт и дополнительно в JTAG порт. А если нет, то происходит выход из процедуры.
********************************************************************/

.global UPDATE_UARTS
UPDATE_UARTS:

	/* сохраняем регистры в стеке */

subi		sp, sp, 28		/* резервируем область памяти в стеке*/ 
stw		ra, 0(sp)
stw		fp, 4(sp)
stw 		r15, 8(sp)
stw 		r16, 12(sp)
stw 		r17, 16(sp)
stw 		r18, 20(sp)
stw 		r19, 24(sp)
addi		fp, sp, 28

movia	 r15, JTAG_UART_BASE       /* помещаем в r15 адрес JTAG UART*/
movia	 r19, UART_BASE                  /* помещаем в r19 адрес com-порта*/

GET_CHAR:
ldwio   r17, 0(r15)		/* считываем слово из регистра данных JTAG UART*/
andi    r18, r17, 0x8000			/* проверяем бит RVALID*/           
beq     r18, r0, GET_CHAR_UART		/* если данных нет в буфере, то переходим на GET_CHAR_UART*/
andi    r16, r17, 0x00ff             	/* выделяем байт данных из считанного из JTAG UART порта слова*/

PUT_CHAR:
ldwio   r17, 4(r15)		/* считываем слово из регистра управления JTAG UART*/
andhi   r17, r17, 0xffff			/* выделяем значение поля workspace*/
beq     r17, r0, PUT_CHAR_UART	        /* если свободного места в буфере нет, то переходим на PUT_CHAR_UART*/
stwio   r16, 0(r15)			/* отправляем символ обратно в JTAG UART*/  

PUT_CHAR_UART:
ldwio   r17, 4(r19)		/* считываем слово из регистра управления com-порта*/	 
andhi   r17, r17, 0xffff			/* выделяем значение поля workspace*/
beq     r17, r0, GET_CHAR_UART	        /* если свободного места нет в буфере, то переходим на GET_CHAR_UART*/
stwio   r16, 0(r19)				/* отправляем символ в com-порт*/

GET_CHAR_UART:                              
ldwio   r17, 0(r19)			/* считываем слово из регистра данных com-порта*/
andhi   r18, r17, 0xFFFF	                /* выделяем значение поля RAVAIL*/
beq     r18, r0, NO_CHAR	      /* если новых данных нет, то переходим на NO_CHAR*/
andi    r16, r17, 0x00ff                     /* выделяем байт данных из считанного из com-порта слова*/

ldwio   r17, 4(r19)		/* считываем слово из регистра управления com-порта*/	 
andhi   r17, r17, 0xffff			/* выделяем значение поля workspace*/
beq     r17, r0, PUT_CHAR_JTAG	        /* если свободного места нет в буфере, то переходим на PUT_CHAR_JTAG*/
stwio   r16, 0(r19)				/* отправляем символ в com-порт*/	 

PUT_CHAR_JTAG:
ldwio   r17, 4(r15)				/* считываем слово из регистра управления JTAG UART*/
andhi   r17, r17, 0xffff		        /* выделяем значение поля workspace*/
beq     r17, r0, NO_CHAR	                /* если свободного места нет в буфере, то переходим на NO_CHAR*/
stwio   r16, 0(r15)				/* отправляем символ в JTAG UART*/	 
NO_CHAR:

	/* извлекаем из стека регистры */

ldw		ra, 0(sp)
ldw		fp, 4(sp)
ldw		r15, 8(sp)
ldw		r16, 12(sp)
ldw		r17, 16(sp)
ldw		r18, 20(sp)
ldw		r19, 24(sp)
addi		sp, sp, 28

ret                                     /* выполняем возврат из процедуры*/
```

