# Лабораторная работа № 7

## Использование интерфейса JTAG для взаимодействия процессорной системы с инструментальным компьютером

**Цель работы:**

Изучение порта UART JTAG и практическое его применение для взаимодействия процессорной системы, реализованной в стенде, с оператором инструментального компьютера.

**Объекты изучения:**

- порт UART JTAG для взаимодействия инструментального компьютера с процессорной системой;
- буферы FIFO, входящие в состав контроллера порта;
- приложение Intel Monitor Program (IMP), а точнее его терминальное окно, предназначенное для коммуникации со стендом.

**Планируемые результаты обучения:**

После выполнения этой работы студенты будут знать:

- Назначение и принцип работы интерфейса JTAG;
- Назначение и принцип работы универсального асинхронного приемопередатчика UART.

Смогут:

- Вводить информацию в процессорную систему, используя клавиатуру инструментального компьютера;
- Выводить информацию из процессорной системы в терминальное окно инструментального компьютера;
- Выполнять ввод и вывод информации с использованием прерываний;
- Использовать вложенные прерывания от таймера для ввода вывода.

Приобретут навыки:

- Взаимодействия оператора инструментального компьютера с процессорной системой через терминальное окно приложения IMP.

## Исходные файлы лабораторной работы

Программа, демонстрирующая использование порта JTAG UART в процессорной системе, входит в состав приложения IMP. Она доступна в разделе Sample program под именем JTAG UART.s. Её листинг с подробными комментариями приведен в приложении 2. Там же приводится фрагмент программы TEST DE 2-70 Media Computer, в котором выполняется взаимодействие с JTAG UART портом.

В файле jtag_uart содержатся две функции putchar_uart и getchar_uart.

Первая функция putchar_uart проверяет поле wspace регистра управления порта. Если оно не равно нулю, значит место в буфере FIFO для записи есть, в этом случае байт из R4 пересылается в UART. Признаком успешного выполнения функции является возврат в регистре R2 нулевого значения. Если места в буфере FIFO нет, то возвращается -1. Функция будет полезна для написания функции вывода текстовой строки в терминальное окно инструментального ПК в первой части работы.

Вторая функция getchar_uart проверяет бит RAVAIL в регистре данных порта UART. Если данные для чтения в буфере FIFO есть, то считанный из него байт помещается в R2. Если данных в буфере нет, то в R2 возвращается -1. Функция будет полезна для написания функции ввода текстовой строки, печатаемой на клавиатуре инструментального ПК, в память процессорной системы. Такую функцию потребуется создать во второй части работы.

В файле display содержатся две подпрограммы hex_display и led_display, которые отображают содержимое регистра R4 на двух 7-сегментных индикаторах и на красных светодиодах, соответственно. Они будут полезны для изучения ASCII кодов символов, печатаемых на клавиатуре инструментального ПК и отправляемых в буфер FIFO порта JTAG UART.

В файле print_lcd представлена одноименная программа, выполняющая вывод текста в режиме бегущей строки на LCD дисплей стенда. Адрес строки передается через регистр R4. Эта программа будет полезна для демонстрации прерываний, происходящих при работе с портом JTAG UART.

## Подготовка к лабораторной работе

Для выполнения лабораторной работы необходимо изучить по материалам лекций и предложенной литературе.

1. Назначение интерфейса JTAG и выполняемые им функции.
2. Организацию обмена данными между стендом и инструментальным компьютером.
3. Принцип работы порта JTAG UART, назначение его регистров, доступных для программы, и их отдельных полей. Эта информация содержится в описании процессорной системы «DE2-70 Media Computer» [9]. Включите ее в отчет.
4. Директиву ассемблера .skip.
5. Реализацию прерываний в процессорной системе с процессором NIOSII[8]. Используемые для этого регистры процессора и портов ввода – вывода.
6. Особенности использования вложенных прерываний.
7. Уясните принцип действия программы, работающей с интерфейсом JTAG из файла JTAG UART.s. Включите ее в отчет.
8. Уясните логику работы программных заготовок, представленных в приложении 2.
9. Уясните пункты задания, предлагаемого в текущей лабораторной работе, и подготовьте программные заготовки для их выполнения.

### Вопросы для самоконтроля

1. Каково назначение интерфейса JTAG? Как расшифровывается эта аббревиатура?
2. Что представляет собой порт ТАР, с какой целью он вводится в состав СБИС?
3. Присутствует ли порт ТАР в кристалле ПЛИС, входящей в состав учебного стенда? Какие функции он выполняет?
4. Какие сигналы используются в порту ТАР, каково их назначение?
5. Как с помощью приложения IMP организовать взаимодействие процессорной системы с инструментальным компьютером?
6. Можно ли клавиатуру инструментального компьютера использовать для ввода информации в процессорную систему, реализованную в стенде? Как это сделать?
7. Можно ли монитор инструментального компьютера использовать для вывода информации из процессорной системы? Как это сделать?
8. Каково назначение регистров и отдельных полей порта JTAG UART?
9. Расшифруйте аббревиатуру UART.
10. Что представляет собой буфер FIFO? Входит ли он в состав контроллера порта JTAG UART?
11. Как организовать ввод информации в процессорную систему через JTAG UART в режиме прерываний?

## Порядок выполнения лабораторной работы

### Часть 1. Запись в UART JTAG (вывод информации)

1. Напишите программу, которая записывает ASCII код заглавной буквы вашей фамилии в порт UART JTAG. Используйте для этого латиницу и функцию putchar_uart, листинг которой приведен в приложении 2. Функция выполняет анализ поля WSPACE в регистре управления UART, отражающего наличие свободного места в буфере FIFO для записываемых данных. Если свободное место в буфере есть, то символ записывается в буфер и в регистре R2 возвращается нулевое значение, свидетельствующее об успешном выполнении функции. В противном случае, если свободного места в буфере нет, функция возвращает в регистре R2 значение -1, свидетельствующее об неуспешном её завершении. Отразите в отчете результат работы программы, наблюдая терминальное окно АМР.

2. Остановите выполнение программы после вывода символа. Используя вкладку Memory приложения IMP, проанализируйте содержимое поля WSPACE регистра управления UART. Следует напомнить, что для этого потребуется включить опцию Query all devices и нажать кнопку Refresh. Отразите в отчете наблюдаемое значение. Определите по нему размер буфера FIFO для записываемых данных и поместите в отчет.

3. Модифицируйте программу из пункта 1 таким образом, чтобы заданный символ выводился в порт UART многократно, то есть в цикле. Причем добавьте программную задержку в цикл вывода. Подберите задержку таким образом, чтобы происходили следующие события.

   а) Буфер FIFO сразу же переполняется, и программа завершает свое выполнение. При этом в терминальное окно IMP выводится минимальное количество символов. Подсчитайте количество выведенных символов. Сравните со значением, полученным в пункте 2.

   б) Буфер FIFO никогда не переполняется, и программа выводит символ в терминальное окно IМР бесконечно.

   в) Буфер FIFO успевает вывести в терминальное окно значительно больше символов, чем в пункте 4, до того, как произойдет его переполнение. Запишите в отчет подобранные задержки и количество выводимых на экран ПК символов. Рекомендуется каждый раз делать снимки экрана и помещать их в отчет.

4. Напишите программу, которая выводит в терминальное окно IMP некоторое сообщение. Сообщение поместите в сегменте данных программы. Для этого используйте директиву .asciz ассемблера. Программа должна анализировать считываемый из строки байт, и если он равен нулю, то вывод строки должен завершиться. Оформите эту программу в виде функции puts_uart, которая в последующем будет использована для вывода из процессорной системы различных сообщений. Параметром, передаваемым этой функции, является адрес текстовой строки в ОП. В качестве тестового примера выведите свою фамилию, имя и отчество. Сделайте снимок экрана инструментального ПК, подтверждающий корректную работу программы, и поместите его вместе с листингом отлаженной программы в отчетные материалы.

### Часть 2. Чтение из JTAG UART (ввод информации)

1. Напишите программу, которая выполняет чтение из порта UART JTAG одного байта с помощью функции getchar_uart, листинг которой приведен в приложении 2. Функция анализирует бит RVALID в регистре данных UART. Если этот бит равен 1, считанные данные присутствовали в буфере FIFO, и они достоверны. В этом случае считанный из буфера байт возвращается в основную программу в регистре R2. В противном случае, если данных в буфере нет, функция возвращает в регистре R2 значение -1, свидетельствующее о неудачном её завершении. В программе анализируется возвращаемое в R2 значение и если попытка чтения была неудачной выполняется повторное чтение из порта UART JTAG. Другими словами, программа должна ожидать появления новых данных в буфере FIFO для чтения. Прочитанный из UART JTAG байт, основная программа должна записать обратно в JTAG с помощью функции putchar_uart и ждать появления следующего байта. И так далее в цикле.

2. С помощью IMP скомпилируйте программу из предыдущего пункта и загрузите её в память процессорной системы. Поставьте контрольную точку в программе после приема первого символа из UART JTAG. Запустите программу. Зафиксируйте в отчете наблюдаемый вами результат её выполнения.

3. Установите курсор мыши в терминальное окно IМР и напечатайте на клавиатуре цифру 0. После останова программы в контрольной точке проанализируйте поле RAVAIL, используя вкладку Memory. Запишите в отчет его значение и значение считанного из UART байта. Обратите внимание! Для анализа поля RAVAIL потребуется включить опцию Query all devices и нажать кнопку Refresh. Учтите, что при этом происходит чтение регистра данных UART JTAG и, следовательно, извлечение символа из вершины буфера FIFO и уменьшение поля RAVAIL на единицу. Напечатайте на клавиатуре еще десять нулей. Проанализируйте еще раз поле RAVAIL и запишите в отчет его новое значение. Поместите в отчет ваше наблюдение о заполнении буфера FIFO. Продолжите печатать на клавиатуре, теперь уже цифру один десять раз, еще раз проанализируйте поле RAVAIL, и зафиксируйте в отчете ваши наблюдения. Экспериментально определите размер буфера FIFO для читаемых данных, продолжая каждый раз печатать на клавиатуре следующие цифры по десять штук и наблюдая за заполнением буфера. После того, как поле RAVAIL перестанет изменяться, сделайте вывод о размере буфера FIFO для чтения, уберите контрольную точку и продолжите выполнение программы в автоматическом режиме. Сравните количество выведенных символов в терминальном окне AMP с ожидаемым результатом. Сделайте снимок экрана ПК и поместите его в отчет вместе с вашим заключением.

4. Модифицируйте программу из предыдущего пункта таким образом, чтобы читаемые из UART байты дополнительно отображались на двух HEX индикаторах и на красных светодиодах. Используйте для этого процедуры hex_display и led_display, листинги которых с подробными комментариями приведены в приложении 2. Составьте таблицу кодов ASCII для десяти цифр и букв вашей фамилии, набирая их на клавиатуре инструментального ПК. Экспериментально определите коды символов Enter, Space, Backspace. Определите коды ASCII для символов прописных и заглавных, а также для символов латинского и русского алфавита. Поместите в отчет заполненную вами таблицу и листинг отлаженной программы.

5. Модифицируйте программу чтения из порта UART JTAG таким образом, чтобы теперь ASCII-коды печатаемых на клавиатуре символов дополнительно заносились в память процессорной системы побайтно, тем самым формируя текстовую строку в ОП. Зарезервируйте для этого 256 байт в секции данных ОП используя директиву ассемблера .skip 256, '^', которая для большей наглядности еще и заполнит эту область ОП символами циркумфлекс. Ввод текстовой строки в ОП должен завершиться после чтения символа Enter. В этом случае в конец символьной строки в ОП должен быть добавлен нулевой байт, означающий конец строки. Убедитесь в корректном выполнении программы, наблюдая во вкладке Memory сформированную ею строку. Оформите её в виде функции gets_uart. Она в последующем будет использована для ввода текстовой информации в процессорную систему с клавиатуры инструментального компьютера. Сделайте снимок зарезервированной области ОП во вкладке Memory с размещенной в ней текстовой строкой, подтверждающий правильное выполнение функции gets_uart. Используйте для этого свою фамилию, имя и отчество.

6. Внесите изменения в программу из предыдущего пункта таким образом, чтобы напечатанная на клавиатуре инструментального ПК текстовая строка целиком пересылалась обратно в порт UART JTAG только после ввода символа Enter. Используйте для этого функцию puts_uart, созданную при выполнении пункта 7 первой части.

### Часть 3. Ввод из UART JTAG в режиме прерывания

1. Реализуйте блокирующий ввод текстовой строки, печатаемой на клавиатуре инструментального компьютера, в режиме прерывания. Для этого основная программа разрешает прерывания по чтению от UART JTAG и выполняет вывод строки с вашей фамилией, именем и отчеством на дисплей LCD в режиме бегущей строки. Ввод текста в терминальном окне инструментального компьютера приводит к прерыванию основной программы, и обработчик прерывания далее осуществляет ввод строки в ОП и вывод в UART JTAG всей строки, пока не обнаружит символ конца строки. В это время вывод бегущей строки на LCD дисплей должен прекратиться.

2. Модифицируйте программу из предыдущего пункта таким образом, чтобы теперь ввод строки стал неблокирующим. То есть, после ввода каждого символа обработчик прерывания возвращает управление основной программе. Визуально наблюдайте корректность выполнения программы.

### Часть 4. Ввод из JTAG UART в режиме прерывания с использованием вложенного прерывания от таймера

1. Модифицируйте программу чтения из порта JTAG UART так, чтобы набранный на клавиатуре ПК символ выводился в терминальное окно ПК каждые 500мс. Используйте для этого прерывания от таймера, формируемые с периодичностью 500 мс.

2. Модифицируйте программу из предыдущей части таким образом, чтобы основная программа разрешила прерывания по чтению от UART JTAG и выводила бегущую строку на LCD. При нажатии клавиши клавиатуры инструментального компьютера формируется прерывание основной программы. Обработчик прерывания UART JTAG разрешает прерывания от таймера каждые 500 мс и возвращает управление основной программе. Обработчик прерывания от таймера выводит символ в терминальное окно IMP каждые 500 мс, причем, если клавиша не нажата, повторяется вывод последнего набранного на клавиатуре ПК символа.

### Часть 5. Вывод из процессорной системы в JTAG UART с использованием вложенного прерывания

Экспериментально определите условие формирования прерывапия текущей программы при выполнении вывода символьной информации в терминальное окно инструментального компьютера. Для этого в основной программе разрешите прерывания по записи от порта JTAG UART и выполняйте запись в буфер FIFO, используя программу из пункта 4 части 1. Как мы видели ранее, выполнение этой программы приводит к переполнению буфера FIFO, предназначенного для записи. Следовательно, должно произойти прерывание программы. Обработчик прерывания должен вывести на экран LCD предупреждающее сообщение, проверить, освободился ли буфер FIFO, и если да, вернуть управление основной программе. Таким образом, обработчик прерывания будет срабатывать как предохранитель, принудительно приостанавливая процесс дальнейшего заполнения символьной информацией буфера FIFO, позволяя тем самым в это время его освободить.

## Отчетные материалы

Отчетные материалы должны содержать:

1. Цель лабораторной работы.
2. Материалы, связанные с подготовкой к работе, включая теоретическую часть.
3. Листинг программы JTAG UART.s и фрагмент программы TEST DE 2-70 Media Computer, в котором выполняется взаимодействие с JTAG UART портом.
4. Листинги функций, предлагаемых в качестве программных заготовок для выполнения отдельных пунктов задания.
5. Листинги программ, написанных и отлаженных студентами в процессе выполнения отдельных пунктов задания.
6. Таблицу с кодами ASCII заполненную в процессе выполнения пункта 2.4 задания.
7. Информацию по выполнению каждого пункта задания. Причем в отчете должны содержаться выполняемые вами действия, наблюдаемые результаты, и ваши объяснения.
8. Написанные и отлаженные вами фрагменты программ.
9. Краткое заключение.

## Приложение

В приложении содержится файл JTAG UART, встроенный в приложение AMP. В этой программе осуществляется вывод текстовой строки из процессорной системы в JTAG UART, и ввод текстовой строки, набираемой в терминальном окне AMP, через JTAG UART и вывод обратно.

В приложении также содержится фрагмент из файла Test_DE2_70_Media_Computer, который полностью приведен в приложении к первой лабораторной работе. В представленном фрагменте выполняется работа с регистрами UART JTAG.

### Листинг 8 Текст программы JTAG UART.s

```assembly
/****************************************************************
 * Программа выполняет следующее: 
 *       1. отправляет символьную строку  из текстовой строки в JTAG UART
 *       2. считывает данные из JTAG UART
 *       3. отправляет считанные данные обратно в JTAG UART
********************************************************************/

.text									
.global	_start
_start:

movia 		sp, 0x07FFFFFC			/* Определяем адрес вершины стека */

movia		r6, 0x10001000			

				
movia		r8, TEXT_STRING			/* адрес текстовой строки в r8 */
:
ldb		r5, 0(r8)			/* из текстовой строки читаем байт в r5*/
call		PUT_JTAG                /* вызываем процедуру, которая помещает символ в JTAG */

addi		r8, r8, 1
	
br					/* переходим на вывод очередного символа */

GET_JTAG:
ldwio		r4, 0(r6)		/*читаем регистр управления JTAG UART*/
andi		r8, r4, 0x8000	           /*проверяем есть ли новые данные*/
beq		r8, r0, GET_JTAG	/*если данных нет, то ожидаем их появления*/
andi		r5, r4, 0x00ff	           /*получаем данные*/

call		PUT_JTAG		/*отправляем символ обратно в JTAG UART*/
br		GET_JTAG

.end		
									
/********************************************************************
* Подпрограмма, которая выводит символы в JTAG UART
*		r5	= выводимый символ
*		r6	= JTAG UART базовый адрес
********************************************************************/

.global	PUT_JTAG			
PUT_JTAG:			
		
	/* сохраняем используемые регистры */	

subi		sp, sp, 4				/* резервирум место в стеке*/
stw		r4, 0(sp)				/* сохраняем r4 в стеке */

ldwio		r4, 4(r6)		/* читаем регистр управления JTAG UART */
andhi		r4, r4, 0xffff	             /* проверяем есть ли место для записи в буфере UART */
beq		r4, r0, KONEC	/* если места нет, то переполнение буфера */
stwio		r5, 0(r6)				/* отправляем символ в UART */
			
OVERFLOW:		
			
	/* восстанавливаем содержимое r4 */

ldw		r4, 0(sp)	
addi		sp, sp, 4	

ret				

               /******************************************************************/

.data			

TEXT_STRING:
.asciz	"\nJTAG UART example code\n"

.end
```

### Листинг 9 Фрагмент программы TEST_DE2_70_Media_Computer

```assembly
/****************************************************************
 * Процедура анализирует, имеются ли данные в буфере чтения JTAG порта.
 * Если есть, то данные отправляются обратно в JTAG порт и дополнительно в 
 * COM-порт. Если новых данных нет, то выполняется проверка, имеются ли данные в буфере чтения com-порта. Если данные есть, то они отправляются обратно в com-порт и дополнительно в JTAG порт. А если нет, то происходит выход из процедуры.
********************************************************************/

.global UPDATE_UARTS
UPDATE_UARTS:

	/* сохраняем регистры в стеке */

subi		sp, sp, 28		/* резервируем область памяти в стеке*/ 
stw		ra, 0(sp)
stw		fp, 4(sp)
stw 		r15, 8(sp)
stw 		r16, 12(sp)
stw 		r17, 16(sp)
stw 		r18, 20(sp)
stw 		r19, 24(sp)
addi		fp, sp, 28

movia	 r15, JTAG_UART_BASE       /* помещаем в r15 адрес JTAG UART*/
movia	 r19, UART_BASE                  /* помещаем в r19 адрес com-порта*/

GET_CHAR:
ldwio   r17, 0(r15)		/* считываем слово из регистра данных JTAG UART*/
andi    r18, r17, 0x8000			/* проверяем бит RVALID*/           
beq     r18, r0, GET_CHAR_UART		/* если данных нет в буфере, то переходим на GET_CHAR_UART*/
andi    r16, r17, 0x00ff             	/* выделяем байт данных из считанного из JTAG UART порта слова*/


PUT_CHAR:
ldwio   r17, 4(r15)		/* считываем слово из регистра управления JTAG UART*/
andhi   r17, r17, 0xffff			/* выделяем значение поля workspace*/
beq     r17, r0, PUT_CHAR_UART	        /* если свободного места в буфере нет, то переходим на PUT_CHAR_UART*/
   stwio   r16, 0(r15)			/* отправляем символ обратно в JTAG UART*/  

PUT_CHAR_UART:
ldwio   r17, 4(r19)		/* считываем слово из регистра управления*/ com-порта*/	 
andhi   r17, r17, 0xffff			/* выделяем значение поля workspace*/
beq     r17, r0, GET_CHAR_UART	        /* если свободного места нет в буфере, то переходим на GET_CHAR_UART*/
stwio   r16, 0(r19)				/* отправляем символ в com-порт*/

GET_CHAR_UART:                              
ldwio   r17, 0(r19)			/* считываем слово из регистра данных com-порта*/
andhi   r18, r17, 0xFFFF	                /* выделяем значение поля RAVAIL*/
beq     r18, r0, NO_CHAR	      * если новых данных нет, то переходим на NO_CHAR*/
andi    r16, r17, 0x00ff                     /* выделяем байт данных из считанного из com-порта слова*/


ldwio   r17, 4(r19)		/* считываем слово из регистра управления com-порта*/	 
andhi   r17, r17, 0xffff			/* выделяем значение поля workspace*/
beq     r17, r0, PUT_CHAR_JTAG	        /* если свободного места нет в буфере, то переходим на PUT_CHAR_JTAG*/
stwio   r16, 0(r19)				/* отправляем символ в com-порт*/	 

PUT_CHAR_JTAG:
ldwio   r17, 4(r15)				/* считываем слово из регистра управления JTAG UART*/
andhi   r17, r17, 0xffff		        /* выделяем значение поля workspace*/
beq     r17, r0, NO_CHAR	                /* если свободного места нет в буфере, то переходим на NO_CHAR*/
stwio   r16, 0(r15)				/* отправляем символ в JTAG UART*/	 
NO_CHAR:

	/* извлекаем из стека регистры */

ldw		ra, 0(sp)
ldw		fp, 4(sp)
ldw		r15, 8(sp)
ldw		r16, 12(sp)
ldw		r17, 16(sp)
ldw		r18, 20(sp)
ldw		r19, 24(sp)
addi		sp, sp, 28

ret                                     /* выполняем возврат из процедуры*/
```

